{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-scroll",
  "type": "registry:component",
  "title": "Infinite Scroll",
  "description": "A bias-based infinite scroll wrapper and hook.",
  "files": [
    {
      "path": "registry/joyco/blocks/infinite-scroll/infinite-scroll.tsx",
      "content": "'use client';\n\nimport {\n  cloneElement,\n  createContext,\n  isValidElement,\n  useContext,\n  useMemo,\n  type ButtonHTMLAttributes,\n  type HTMLAttributes,\n  type MouseEvent,\n  type MouseEventHandler,\n  type ReactElement,\n  type ReactNode,\n} from 'react';\n\nimport { useInfiniteScroll, type UseInfiniteScrollOptions, type UseInfiniteScrollResult } from './use-infinite-scroll';\n\ntype DebugPlacement = 'inline' | 'floating';\n\ntype DebugConfig = {\n  enabled?: boolean;\n  placement?: DebugPlacement;\n};\n\ntype InfiniteScrollContextValue<TItem> = UseInfiniteScrollResult<TItem> & {\n  debugEnabled: boolean;\n  debugPlacement: DebugPlacement;\n};\n\ntype AnyInfiniteScrollState = InfiniteScrollContextValue<unknown>;\n\nconst InfiniteScrollContext = createContext<AnyInfiniteScrollState | null>(null);\n\nexport function useInfiniteScrollState<TItem>(): InfiniteScrollContextValue<TItem> {\n  const context = useContext(InfiniteScrollContext);\n\n  if (!context) {\n    throw new Error('InfiniteScroll components must be used within `InfiniteScroll.Provider`.');\n  }\n\n  return context as InfiniteScrollContextValue<TItem>;\n}\n\ntype ProviderProps<TItem> = {\n  children: ReactNode;\n  debug?: boolean | DebugConfig;\n} & UseInfiniteScrollOptions<TItem>;\n\nexport function InfiniteScrollProvider<TItem>({ children, debug = false, ...options }: ProviderProps<TItem>) {\n  const state = useInfiniteScroll<TItem>(options);\n\n  const debugConfig: DebugConfig =\n    typeof debug === 'boolean'\n      ? {\n          enabled: debug,\n        }\n      : debug ?? { enabled: false };\n\n  const debugEnabled = debugConfig.enabled ?? (typeof debug === 'boolean' ? debug : true);\n  const debugPlacement: DebugPlacement = debugConfig.placement ?? (debugEnabled ? 'floating' : 'inline');\n\n  const value = useMemo(\n    () =>\n      ({\n        ...state,\n        debugEnabled,\n        debugPlacement,\n      } as InfiniteScrollContextValue<TItem>),\n    [state, debugEnabled, debugPlacement]\n  );\n\n  return (\n    <InfiniteScrollContext.Provider value={value as AnyInfiniteScrollState}>{children}</InfiniteScrollContext.Provider>\n  );\n}\n\ntype RootProps = HTMLAttributes<HTMLDivElement>;\n\nfunction InfiniteScrollRoot({ children, ...rest }: RootProps) {\n  return <div {...rest}>{children}</div>;\n}\n\ntype ViewportProps = HTMLAttributes<HTMLDivElement>;\n\nfunction InfiniteScrollViewport({ children, ...rest }: ViewportProps) {\n  return <div {...rest}>{children}</div>;\n}\n\ninterface ItemProps extends HTMLAttributes<HTMLDivElement> {\n  index: number;\n  asChild?: boolean;\n  children: ReactNode;\n}\n\nfunction InfiniteScrollItem({ index, asChild = false, children, ...rest }: ItemProps) {\n  const { visibleCount } = useInfiniteScrollState<unknown>();\n\n  const baseProps = {\n    ...rest,\n    'data-index': index,\n    'data-visible': index < visibleCount ? '' : undefined,\n  };\n\n  if (asChild && isValidElement(children)) {\n    return cloneElement(children as ReactElement, baseProps);\n  }\n\n  return <div {...baseProps}>{children}</div>;\n}\n\ninterface TriggerProps extends ButtonHTMLAttributes<HTMLButtonElement> {\n  asChild?: boolean;\n  children: ReactNode;\n}\n\nfunction InfiniteScrollTrigger({ asChild = false, children, disabled, onClick, type, ...rest }: TriggerProps) {\n  const { loadMore, loading, hasMore } = useInfiniteScrollState<unknown>();\n\n  const isDisabled = disabled ?? (!hasMore || loading);\n\n  const runClickPipeline = (event: MouseEvent<HTMLElement>) => {\n    if (isDisabled) {\n      event.preventDefault();\n      return;\n    }\n\n    onClick?.(event as unknown as MouseEvent<HTMLButtonElement>);\n    loadMore();\n  };\n\n  const handleButtonClick: MouseEventHandler<HTMLButtonElement> = (event) => {\n    runClickPipeline(event);\n  };\n\n  if (asChild && isValidElement(children)) {\n    const child = children as ReactElement<Record<string, unknown>>;\n\n    return cloneElement(child, {\n      ...(rest as Record<string, unknown>),\n      disabled: isDisabled,\n      'data-loading': loading ? '' : undefined,\n      'data-has-more': hasMore ? '' : undefined,\n      onClick: (event: MouseEvent<HTMLElement>) => {\n        const childOnClick = child.props?.onClick;\n        if (typeof childOnClick === 'function') {\n          childOnClick(event);\n        }\n        runClickPipeline(event);\n      },\n    });\n  }\n\n  return (\n    <button\n      type={type ?? 'button'}\n      disabled={isDisabled}\n      onClick={handleButtonClick}\n      data-loading={loading ? '' : undefined}\n      data-has-more={hasMore ? '' : undefined}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n}\n\ntype SentinelProps = HTMLAttributes<HTMLDivElement>;\n\nfunction InfiniteScrollSentinel({ children, ...rest }: SentinelProps) {\n  const { sentinelRef } = useInfiniteScrollState<unknown>();\n\n  return (\n    <div ref={sentinelRef} {...rest}>\n      {children}\n    </div>\n  );\n}\n\ntype Tone = 'blue' | 'green' | 'amber' | 'slate' | 'rose';\n\nconst toneBadgeClass: Record<Tone, string> = {\n  blue: 'bg-blue-500 text-white',\n  green: 'bg-emerald-500 text-white',\n  amber: 'bg-amber-500 text-white',\n  slate: 'bg-slate-600 text-white',\n  rose: 'bg-rose-500 text-white',\n};\n\ninterface DebugStatProps {\n  label: string;\n  value: ReactNode;\n  tone: Tone;\n}\n\nfunction DebugStat({ label, value, tone }: DebugStatProps) {\n  return (\n    <div className=\"flex flex-col gap-2 rounded-md border border-border/60 bg-background/70 p-3\">\n      <span className=\"text-[10px] font-semibold uppercase tracking-wide text-muted-foreground\">{label}</span>\n      <span\n        className={`inline-flex min-h-[1.5rem] items-center justify-center rounded-full px-2 text-xs ${toneBadgeClass[tone]}`}\n      >\n        {value}\n      </span>\n    </div>\n  );\n}\n\ninterface DebugProps extends HTMLAttributes<HTMLDivElement> {\n  enabled?: boolean;\n  placement?: DebugPlacement;\n}\n\nfunction InfiniteScrollDebug({ className, enabled, placement, ...rest }: DebugProps) {\n  const {\n    debugEnabled,\n    debugPlacement,\n    requestedPage,\n    pageSize,\n    bias,\n    visibleItems,\n    visibleCount,\n    items,\n    hasMore,\n    loading,\n    error,\n    totalCount,\n  } = useInfiniteScrollState<unknown>();\n\n  const isEnabled = enabled ?? debugEnabled;\n  const resolvedPlacement = placement ?? debugPlacement;\n\n  if (!isEnabled) {\n    return null;\n  }\n\n  const baseClass =\n    'space-y-3 rounded-lg border border-primary/30 bg-primary/5 p-4 text-xs shadow-sm backdrop-blur-sm md:max-w-sm';\n\n  const placementClass =\n    resolvedPlacement === 'floating'\n      ? 'pointer-events-auto fixed bottom-6 right-6 z-50 w-[min(22rem,calc(100vw-3rem))] max-w-sm'\n      : '';\n\n  const containerClass = [baseClass, placementClass, className].filter(Boolean).join(' ');\n\n  return (\n    <div className={containerClass} {...rest}>\n      <div className=\"flex items-center justify-between\">\n        <span className=\"text-[11px] font-semibold uppercase tracking-wide text-primary\">Infinite Scroll Debug</span>\n        <span\n          className={`inline-flex items-center rounded-full px-2 py-0.5 text-[10px] font-semibold ${\n            loading ? toneBadgeClass.rose : toneBadgeClass.green\n          }`}\n        >\n          {loading ? 'Loading…' : 'Idle'}\n        </span>\n      </div>\n\n      <div className=\"grid gap-2 sm:grid-cols-2\">\n        <DebugStat label=\"Requested Page\" value={`#${requestedPage}`} tone=\"blue\" />\n        <DebugStat label=\"Page Size\" value={pageSize} tone=\"slate\" />\n        <DebugStat label=\"Bias\" value={bias} tone=\"amber\" />\n        <DebugStat label=\"Visible Count\" value={visibleCount} tone=\"green\" />\n        <DebugStat label=\"Loaded Count\" value={items.length} tone=\"amber\" />\n        <DebugStat label=\"Has More\" value={hasMore ? 'Yes' : 'No'} tone={hasMore ? 'blue' : 'rose'} />\n      </div>\n\n      <div className=\"space-y-2\">\n        <div className=\"text-[10px] uppercase tracking-wide text-muted-foreground\">Visible Item IDs</div>\n        <div className=\"flex flex-wrap gap-1\">\n          {visibleItems.length ? (\n            visibleItems.slice(0, 12).map((item, index) => {\n              const identifier = getItemIdentifier(item);\n              return (\n                <span\n                  key={`${identifier}-${index}`}\n                  className=\"inline-flex items-center rounded-md bg-blue-500/10 px-2 py-1 text-[11px] font-medium text-blue-700\"\n                >\n                  {identifier}\n                </span>\n              );\n            })\n          ) : (\n            <span className=\"text-[11px] text-muted-foreground\">None visible</span>\n          )}\n          {visibleItems.length > 12 ? (\n            <span className=\"inline-flex items-center rounded-md bg-slate-500/10 px-2 py-1 text-[11px] text-slate-600\">\n              +{visibleItems.length - 12} more\n            </span>\n          ) : null}\n        </div>\n      </div>\n\n      <div className=\"flex items-center justify-between text-[11px] text-muted-foreground\">\n        <span>Total Count</span>\n        <span>{typeof totalCount === 'number' ? totalCount : 'Unknown'}</span>\n      </div>\n\n      {error ? (\n        <div className=\"rounded-md border border-rose-400/40 bg-rose-500/10 p-2 text-[11px] text-rose-600\">\n          Error: {String(error)}\n        </div>\n      ) : null}\n    </div>\n  );\n}\n\nfunction getItemIdentifier(item: unknown): string {\n  if (item === null || typeof item === 'undefined') {\n    return '—';\n  }\n\n  if (typeof item === 'object') {\n    const record = item as Record<string, unknown>;\n    if (typeof record.id === 'string' || typeof record.id === 'number') {\n      return String(record.id);\n    }\n  }\n\n  if (typeof item === 'string' || typeof item === 'number') {\n    return String(item);\n  }\n\n  return '—';\n}\n\nexport const InfiniteScroll = {\n  Provider: InfiniteScrollProvider,\n  Root: InfiniteScrollRoot,\n  Viewport: InfiniteScrollViewport,\n  Item: InfiniteScrollItem,\n  Trigger: InfiniteScrollTrigger,\n  Sentinel: InfiniteScrollSentinel,\n  Debug: InfiniteScrollDebug,\n} as const;\n\nexport type { UseInfiniteScrollOptions, UseInfiniteScrollResult } from './use-infinite-scroll';\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/infinite-scroll/use-infinite-scroll.ts",
      "content": "'use client';\n\nimport * as React from 'react';\n\ntype LoadPageResult<TItem> = {\n  items: TItem[];\n  totalCount?: number | null;\n};\n\ntype LoadPageArgs = {\n  offset: number;\n  limit: number;\n  page: number;\n};\n\nexport type LoadPageFn<TItem> = (context: LoadPageArgs) => Promise<LoadPageResult<TItem>>;\n\nexport interface UseInfiniteScrollOptions<TItem> {\n  loadPage: LoadPageFn<TItem>;\n  pageSize?: number;\n  bias?: number;\n  initialPage?: number;\n  mergeItems?: (previous: TItem[], incoming: TItem[]) => TItem[];\n  autoAdvance?: boolean;\n  observerOptions?: IntersectionObserverInit;\n  enabled?: boolean;\n  initialItems?: TItem[];\n  initialTotalCount?: number | null;\n  initialFetched?: number;\n}\n\nexport interface UseInfiniteScrollResult<TItem> {\n  items: TItem[];\n  visibleItems: TItem[];\n  visibleCount: number;\n  pageSize: number;\n  bias: number;\n  requestedPage: number;\n  loading: boolean;\n  error: string | null;\n  totalCount: number | null;\n  hasMore: boolean;\n  sentinelRef: React.RefObject<HTMLDivElement | null>;\n  advancePage: () => void;\n  loadMore: () => void;\n  retry: () => void;\n  reset: () => void;\n}\n\nexport function useInfiniteScroll<TItem>(options: UseInfiniteScrollOptions<TItem>): UseInfiniteScrollResult<TItem> {\n  const {\n    loadPage,\n    pageSize: pageSizeProp = 20,\n    bias: biasProp,\n    initialPage = 1,\n    mergeItems = (previous: TItem[], incoming: TItem[]) => [...previous, ...incoming],\n    autoAdvance = true,\n    observerOptions,\n    enabled = true,\n    initialItems: initialItemsProp,\n    initialTotalCount,\n    initialFetched,\n  } = options;\n\n  const pageSize = pageSizeProp;\n  const bias = biasProp ?? pageSize;\n  const initialLimit = pageSize + bias;\n\n  const initialItemsRef = React.useRef<TItem[]>(initialItemsProp ?? []);\n  const initialFetchedRef = React.useRef<number>(\n    typeof initialFetched === 'number' ? initialFetched : initialItemsRef.current.length\n  );\n  const initialTotalCountRef = React.useRef<number | null>(\n    typeof initialTotalCount === 'number' || initialTotalCount === null ? initialTotalCount : null\n  );\n\n  const [items, setItems] = React.useState<TItem[]>(() => initialItemsRef.current);\n  const [requestedPage, setRequestedPage] = React.useState(() => {\n    const initialCount = initialFetchedRef.current;\n    if (initialCount > 0 && pageSize > 0) {\n      return Math.max(initialPage, Math.ceil(initialCount / pageSize));\n    }\n\n    return initialPage;\n  });\n  const [totalCount, setTotalCount] = React.useState<number | null>(() => initialTotalCountRef.current);\n  const [error, setError] = React.useState<string | null>(null);\n  const [loading, setLoading] = React.useState(false);\n\n  const sentinelRef = React.useRef<HTMLDivElement | null>(null);\n  const initialisedRef = React.useRef(initialItemsRef.current.length > 0);\n\n  React.useEffect(() => {\n    initialItemsRef.current = initialItemsProp ?? [];\n  }, [initialItemsProp]);\n\n  React.useEffect(() => {\n    initialFetchedRef.current = typeof initialFetched === 'number' ? initialFetched : initialItemsRef.current.length;\n  }, [initialFetched, initialItemsProp]);\n\n  React.useEffect(() => {\n    if (typeof initialTotalCount === 'number' || initialTotalCount === null) {\n      initialTotalCountRef.current = initialTotalCount;\n    }\n  }, [initialTotalCount]);\n\n  React.useEffect(() => {\n    if (typeof initialItemsProp === 'undefined') {\n      return;\n    }\n\n    const nextItems = initialItemsProp ?? [];\n    const nextCount = typeof initialFetched === 'number' ? initialFetched : nextItems.length;\n\n    setItems(nextItems);\n    setRequestedPage(() => {\n      if (nextItems.length === 0) {\n        return initialPage;\n      }\n\n      return Math.max(initialPage, Math.ceil(Math.max(nextCount, 0) / pageSize));\n    });\n\n    if (typeof initialTotalCount === 'number' || initialTotalCount === null) {\n      setTotalCount(initialTotalCount);\n    }\n\n    initialisedRef.current = nextItems.length > 0;\n  }, [initialItemsProp, initialFetched, initialTotalCount, initialPage, pageSize]);\n\n  const hasMore = totalCount === null || items.length < totalCount;\n  const visibleCount = Math.min(requestedPage * pageSize, items.length);\n  const visibleItems = React.useMemo(() => items.slice(0, visibleCount), [items, visibleCount]);\n\n  const loadChunk = React.useCallback(\n    async (offset: number, limit: number) => {\n      if (!enabled) {\n        return;\n      }\n\n      if (loading) {\n        return;\n      }\n\n      setLoading(true);\n      setError(null);\n\n      try {\n        const page = Math.floor(offset / pageSize) + 1;\n        const result = await loadPage({ offset, limit, page });\n        const incoming = Array.isArray(result.items) ? result.items : [];\n\n        setItems((previous: TItem[]) => mergeItems(previous, incoming));\n\n        if (typeof result.totalCount === 'number') {\n          setTotalCount(result.totalCount);\n        } else if (result.totalCount === null) {\n          setTotalCount(null);\n        }\n      } catch (cause) {\n        setError(cause instanceof Error ? cause.message : 'Unknown error.');\n      } finally {\n        setLoading(false);\n      }\n    },\n    [enabled, loadPage, loading, mergeItems, pageSize]\n  );\n\n  const ensureBiasAhead = React.useCallback(() => {\n    if (!enabled || loading || !hasMore) {\n      return;\n    }\n\n    const required = requestedPage * pageSize + bias;\n\n    if (items.length >= required) {\n      return;\n    }\n\n    const oldPage = Math.max(0, requestedPage - 1);\n    const nextOffset = oldPage * pageSize + bias;\n    const offset = Math.max(nextOffset, items.length);\n\n    void loadChunk(offset, pageSize);\n  }, [bias, enabled, hasMore, items.length, loadChunk, loading, pageSize, requestedPage]);\n\n  const advancePage = React.useCallback(() => {\n    if (!enabled) {\n      return;\n    }\n\n    setRequestedPage((current: number) => {\n      const next = current + 1;\n\n      if (totalCount !== null) {\n        const maxPages = Math.ceil(totalCount / pageSize);\n\n        if (next > maxPages) {\n          return current;\n        }\n      }\n\n      return next;\n    });\n  }, [enabled, pageSize, totalCount]);\n\n  const reset = React.useCallback(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const nextItems = initialItemsRef.current;\n    const nextTotalCount = initialTotalCountRef.current ?? null;\n    const nextFetched = typeof initialFetchedRef.current === 'number' ? initialFetchedRef.current : nextItems.length;\n\n    setItems(nextItems);\n    setRequestedPage(() => {\n      if (nextItems.length === 0) {\n        return initialPage;\n      }\n\n      return Math.max(initialPage, Math.ceil(Math.max(nextFetched, nextItems.length) / pageSize));\n    });\n    setTotalCount(nextTotalCount);\n    setError(null);\n    const hasInitialItems = nextItems.length > 0;\n    initialisedRef.current = hasInitialItems;\n\n    if (!hasInitialItems) {\n      void loadChunk(0, initialLimit);\n    } else {\n      setTimeout(() => {\n        ensureBiasAhead();\n      }, 0);\n    }\n  }, [enabled, ensureBiasAhead, initialLimit, initialPage, loadChunk, pageSize]);\n\n  const retry = React.useCallback(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (error) {\n      setError(null);\n    }\n\n    ensureBiasAhead();\n  }, [enabled, ensureBiasAhead, error]);\n\n  const loadMore = React.useCallback(() => {\n    advancePage();\n  }, [advancePage]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (initialisedRef.current) {\n      return;\n    }\n\n    initialisedRef.current = true;\n    void loadChunk(0, initialLimit);\n  }, [enabled, initialLimit, loadChunk]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    ensureBiasAhead();\n  }, [enabled, ensureBiasAhead]);\n\n  React.useEffect(() => {\n    if (!enabled || !autoAdvance) {\n      return;\n    }\n\n    if (!hasMore) {\n      return;\n    }\n\n    const node = sentinelRef.current;\n\n    if (!node) {\n      return;\n    }\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          advancePage();\n        }\n      });\n    }, observerOptions ?? { rootMargin: '200px 0px' });\n\n    observer.observe(node);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [advancePage, autoAdvance, enabled, hasMore, observerOptions]);\n\n  return {\n    items,\n    visibleItems,\n    visibleCount,\n    pageSize,\n    bias,\n    requestedPage,\n    loading,\n    error,\n    totalCount,\n    hasMore,\n    sentinelRef,\n    advancePage,\n    loadMore,\n    retry,\n    reset,\n  };\n}\n",
      "type": "registry:hook"
    }
  ]
}