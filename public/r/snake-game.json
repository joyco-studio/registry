{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "snake-game",
  "type": "registry:component",
  "title": "Snake Game",
  "description": "A minimal, themeable snake game component with highscore persistence.",
  "registryDependencies": [
    "button",
    "kbd"
  ],
  "files": [
    {
      "path": "registry/joyco/blocks/snake-game/index.ts",
      "content": "// Component\nexport { SnakeGame } from './snake-game'\n\n// Hook (for advanced usage)\nexport { useSnakeGame } from './use-snake-game'\n\n// Types\nexport type {\n  // Core game types\n  GameState,\n  GameSnapshot,\n  GameEndResult,\n  Direction,\n\n  // Geometry\n  Position,\n\n  // Game objects\n  Snake,\n  Food,\n  HighscoreEntry,\n\n  // Configuration\n  SnakeGameConfig,\n  SnakeGameProps,\n  SnakeGameColors,\n  SnakeGameGrid,\n  SnakeGamePhysics,\n  SnakeGameScoring,\n  SnakeGameStorage,\n\n  // Utilities\n  DeepPartial,\n  CanvasDimensions,\n} from './types'\n\n// Config presets\nexport {\n  DEFAULT_CONFIG,\n  DEFAULT_COLORS,\n  GAME_CONSTANTS,\n  KEY_BINDINGS,\n  DIRECTION_VECTORS,\n  OPPOSITE_DIRECTIONS,\n} from './config'\n\n// Utility functions (for custom implementations)\nexport {\n  mergeConfig,\n  createInitialSnake,\n  generateFood,\n  positionsEqual,\n  isWithinBounds,\n  checkSelfCollision,\n  resolveCssColor,\n  formatHighscoreDate,\n  calculateSpeed,\n  storage,\n} from './utils'\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/snake-game/snake-game.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\nimport { Button } from '@/components/ui/button'\nimport { Kbd } from '@/components/ui/kbd'\nimport type {\n  SnakeGameProps,\n  SnakeGameConfig,\n  CanvasDimensions,\n  GameSnapshot,\n  Direction,\n} from './types'\nimport { DEFAULT_CONFIG, KEY_BINDINGS, GAME_CONSTANTS } from './config'\nimport { useSnakeGame } from './use-snake-game'\nimport { mergeConfig, resolveCssColor } from './utils'\n\n/**\n * Render game to canvas\n */\nfunction renderGame(\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  snapshot: GameSnapshot,\n  config: SnakeGameConfig,\n  dimensions: CanvasDimensions\n): void {\n  const { size, cellSize, dpr } = dimensions\n\n  // Clear canvas\n  ctx.clearRect(0, 0, size * dpr, size * dpr)\n\n  // Reset transform and scale for DPR\n  ctx.setTransform(1, 0, 0, 1, 0, 0)\n  ctx.scale(dpr, dpr)\n\n  // Disable image smoothing for crisp pixels\n  ctx.imageSmoothingEnabled = false\n\n  // Resolve colors\n  const snakeColor = resolveCssColor(config.colors.snake, canvas)\n  const foodColor = resolveCssColor(config.colors.food, canvas)\n\n  // Use integer cell size for crisp rendering\n  const cell = Math.floor(cellSize)\n\n  // Draw snake\n  ctx.fillStyle = snakeColor\n  snapshot.snake.segments.forEach((segment) => {\n    ctx.fillRect(segment.x * cell, segment.y * cell, cell, cell)\n  })\n\n  // Draw food\n  ctx.fillStyle = foodColor\n  ctx.fillRect(\n    snapshot.food.position.x * cell,\n    snapshot.food.position.y * cell,\n    cell,\n    cell\n  )\n}\n\n/**\n * Snake Game Component\n *\n * A minimal, themeable snake game that uses shadcn CSS variables\n * for automatic light/dark theme support.\n *\n * @example\n * ```tsx\n * <SnakeGame\n *   config={{ grid: { size: 15 } }}\n *   onGameEnd={({ score }) => console.log('Game over!', score)}\n *   className=\"w-full\"\n * />\n * ```\n */\nexport function SnakeGame({\n  config: configOverrides,\n  onGameEnd,\n  onScoreChange,\n  onStateChange,\n  className,\n  showControls = true,\n  showHighscores = true,\n}: SnakeGameProps) {\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  const canvasRef = React.useRef<HTMLCanvasElement>(null)\n  const [dimensions, setDimensions] = React.useState<CanvasDimensions>({\n    size: 180,\n    cellSize: 9,\n    dpr: 1,\n  })\n  const [theme, setTheme] = React.useState('')\n\n  // Merge config with defaults\n  const config = React.useMemo<SnakeGameConfig>(\n    () => mergeConfig(DEFAULT_CONFIG, configOverrides),\n    [configOverrides]\n  )\n\n  // Use game hook\n  const {\n    gameState,\n    snapshot,\n    startGame,\n    pauseGame,\n    resumeGame,\n    resetGame,\n    setDirection,\n  } = useSnakeGame({\n    config,\n    onGameEnd,\n    onScoreChange,\n    onStateChange,\n  })\n\n  // Handle responsive sizing\n  React.useEffect(() => {\n    const container = containerRef.current\n    if (!container) return\n\n    const updateSize = () => {\n      const rect = container.getBoundingClientRect()\n      // Round down to nearest multiple of grid size for clean pixels\n      const size =\n        Math.floor(rect.width / config.grid.size) * config.grid.size ||\n        config.grid.size * 9\n      const cellSize = size / config.grid.size\n      const dpr = window.devicePixelRatio || 1\n\n      setDimensions({ size, cellSize, dpr })\n    }\n\n    updateSize()\n\n    const resizeObserver = new ResizeObserver(updateSize)\n    resizeObserver.observe(container)\n\n    return () => resizeObserver.disconnect()\n  }, [config.grid.size])\n\n  // Listen for theme changes\n  React.useEffect(() => {\n    const html = document.documentElement\n    setTheme(html.className)\n\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.attributeName === 'class') {\n          setTheme(html.className)\n        }\n      }\n    })\n\n    observer.observe(html, { attributes: true, attributeFilter: ['class'] })\n    return () => observer.disconnect()\n  }, [])\n\n  // Render game\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext('2d')\n    if (!ctx) return\n\n    // Set canvas size for DPR\n    canvas.width = dimensions.size * dimensions.dpr\n    canvas.height = dimensions.size * dimensions.dpr\n\n    renderGame(ctx, canvas, snapshot, config, dimensions)\n  }, [snapshot, config, dimensions, theme])\n\n  // Keyboard controls\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const key = e.key\n      const code = e.code\n\n      if (gameState === 'playing') {\n        let newDirection: Direction | null = null\n\n        if (KEY_BINDINGS.UP.includes(key) || KEY_BINDINGS.UP.includes(code)) {\n          newDirection = 'UP'\n        } else if (\n          KEY_BINDINGS.DOWN.includes(key) ||\n          KEY_BINDINGS.DOWN.includes(code)\n        ) {\n          newDirection = 'DOWN'\n        } else if (\n          KEY_BINDINGS.LEFT.includes(key) ||\n          KEY_BINDINGS.LEFT.includes(code)\n        ) {\n          newDirection = 'LEFT'\n        } else if (\n          KEY_BINDINGS.RIGHT.includes(key) ||\n          KEY_BINDINGS.RIGHT.includes(code)\n        ) {\n          newDirection = 'RIGHT'\n        }\n\n        if (newDirection) {\n          setDirection(newDirection)\n          e.preventDefault()\n        }\n\n        if (\n          KEY_BINDINGS.PAUSE.includes(key) ||\n          KEY_BINDINGS.PAUSE.includes(code)\n        ) {\n          pauseGame()\n          e.preventDefault()\n        }\n      } else if (gameState === 'paused') {\n        if (\n          KEY_BINDINGS.PAUSE.includes(key) ||\n          KEY_BINDINGS.PAUSE.includes(code) ||\n          KEY_BINDINGS.START.includes(key) ||\n          KEY_BINDINGS.START.includes(code)\n        ) {\n          resumeGame()\n          e.preventDefault()\n        }\n      } else if (gameState === 'idle' || gameState === 'gameOver') {\n        if (\n          KEY_BINDINGS.START.includes(key) ||\n          KEY_BINDINGS.START.includes(code)\n        ) {\n          startGame()\n          e.preventDefault()\n        }\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [gameState, setDirection, startGame, pauseGame, resumeGame])\n\n  // Touch/swipe controls\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    let touchStart: { x: number; y: number } | null = null\n\n    const handleTouchStart = (e: TouchEvent) => {\n      const touch = e.touches[0]\n      touchStart = { x: touch.clientX, y: touch.clientY }\n    }\n\n    const handleTouchEnd = (e: TouchEvent) => {\n      if (!touchStart || gameState !== 'playing') return\n\n      const touch = e.changedTouches[0]\n      const deltaX = touch.clientX - touchStart.x\n      const deltaY = touch.clientY - touchStart.y\n\n      if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        // Horizontal swipe\n        if (deltaX > GAME_CONSTANTS.MIN_SWIPE_DISTANCE) {\n          setDirection('RIGHT')\n        } else if (deltaX < -GAME_CONSTANTS.MIN_SWIPE_DISTANCE) {\n          setDirection('LEFT')\n        }\n      } else {\n        // Vertical swipe\n        if (deltaY > GAME_CONSTANTS.MIN_SWIPE_DISTANCE) {\n          setDirection('DOWN')\n        } else if (deltaY < -GAME_CONSTANTS.MIN_SWIPE_DISTANCE) {\n          setDirection('UP')\n        }\n      }\n\n      touchStart = null\n    }\n\n    canvas.addEventListener('touchstart', handleTouchStart, { passive: true })\n    canvas.addEventListener('touchend', handleTouchEnd, { passive: true })\n\n    return () => {\n      canvas.removeEventListener('touchstart', handleTouchStart)\n      canvas.removeEventListener('touchend', handleTouchEnd)\n    }\n  }, [gameState, setDirection])\n\n  const handlePlayClick = () => {\n    if (gameState === 'idle' || gameState === 'gameOver') {\n      startGame()\n    }\n  }\n\n  return (\n    <div\n      data-slot=\"snake-game\"\n      data-state={gameState}\n      className={cn('bg-background flex w-full flex-col items-center', className)}\n    >\n      {/* Game Canvas */}\n      <div\n        ref={containerRef}\n        data-slot=\"snake-game-canvas\"\n        className=\"bg-muted aspect-square w-full\"\n      >\n        <canvas\n          ref={canvasRef}\n          style={{ width: dimensions.size, height: dimensions.size }}\n          className=\"bg-muted size-full\"\n          role=\"img\"\n          aria-label={`Snake game - ${gameState === 'playing' ? `Score: ${snapshot.score}` : gameState}`}\n        />\n      </div>\n\n      {/* Controls Bar */}\n      {showControls && (\n        <div\n          data-slot=\"snake-game-controls\"\n          className=\"text-muted-foreground border-background flex w-full items-center justify-center border-t-4 font-mono text-xs\"\n        >\n          {gameState === 'gameOver' ? (\n            <div className=\"flex w-full items-center gap-1 pl-2\">\n              <span className=\"flex-1 uppercase\">\n                <span className=\"font-bold\">F*ck!</span> Score:{' '}\n                <span className=\"text-foreground font-bold\">\n                  {snapshot.score}\n                </span>\n              </span>\n              <Button\n                onClick={handlePlayClick}\n                size=\"sm\"\n                className=\"h-8 rounded-none text-xs font-medium uppercase\"\n              >\n                Play again\n              </Button>\n            </div>\n          ) : gameState === 'playing' ? (\n            <div className=\"flex w-full items-center gap-1\">\n              <div className=\"flex flex-1 px-3 whitespace-pre\">\n                Score:\n                <span className=\"text-foreground font-bold\">\n                  {' '}\n                  {snapshot.score}\n                </span>\n              </div>\n              <span className=\"flex h-8 w-full shrink items-center pl-2\">\n                <div className=\"ml-auto flex gap-0.5\">\n                  {[\n                    { desktop: 'W', mobile: '↑' },\n                    { desktop: 'A', mobile: '←' },\n                    { desktop: 'S', mobile: '↓' },\n                    { desktop: 'D', mobile: '→' },\n                  ].map(({ desktop, mobile }) => (\n                    <Kbd key={desktop} className=\"rounded-none text-[10px]\">\n                      <span className=\"max-md:hidden\">{desktop}</span>\n                      <span className=\"md:hidden\">{mobile}</span>\n                    </Kbd>\n                  ))}\n                </div>\n              </span>\n            </div>\n          ) : gameState === 'paused' ? (\n            <Button\n              onClick={resumeGame}\n              size=\"sm\"\n              className=\"h-8 w-full rounded-none text-xs font-medium uppercase\"\n            >\n              Resume\n            </Button>\n          ) : (\n            <Button\n              onClick={handlePlayClick}\n              size=\"sm\"\n              className=\"h-8 w-full rounded-none text-xs font-medium uppercase\"\n            >\n              Play Snake\n            </Button>\n          )}\n        </div>\n      )}\n\n      {/* High Scores */}\n      {showHighscores && snapshot.highscores.length > 0 && (\n        <div\n          data-slot=\"snake-game-highscores\"\n          className=\"border-background bg-accent/10 flex w-full flex-col border-t-4 px-3 py-2\"\n        >\n          <span className=\"text-muted-foreground/60 mb-1 text-[10px] uppercase\">\n            Highscores\n          </span>\n          {snapshot.highscores.map((entry, i) => (\n            <div\n              key={`${entry.score}-${entry.date}-${i}`}\n              className=\"text-muted-foreground flex items-center justify-between text-xs\"\n            >\n              <span>\n                <span className=\"text-foreground font-bold\">{entry.score}</span>{' '}\n                pts\n              </span>\n              <span className=\"text-muted-foreground/60\">{entry.date}</span>\n            </div>\n          ))}\n        </div>\n      )}\n\n      {/* Screen reader announcements */}\n      <div className=\"sr-only\" aria-live=\"polite\" aria-atomic=\"true\">\n        {gameState === 'gameOver' &&\n          `Game over. Final score: ${snapshot.score}`}\n      </div>\n    </div>\n  )\n}\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/snake-game/types.ts",
      "content": "/** Game state machine states */\nexport type GameState = 'idle' | 'playing' | 'paused' | 'gameOver'\n\n/** Direction the snake can move */\nexport type Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT'\n\n/** 2D position on the grid */\nexport interface Position {\n  x: number\n  y: number\n}\n\n/** High score entry */\nexport interface HighscoreEntry {\n  score: number\n  date: string\n}\n\n/** Snake state */\nexport interface Snake {\n  segments: Position[]\n  direction: Direction\n  nextDirection: Direction\n}\n\n/** Food state */\nexport interface Food {\n  position: Position\n}\n\n/** Complete game state snapshot */\nexport interface GameSnapshot {\n  state: GameState\n  snake: Snake\n  food: Food\n  score: number\n  highscores: HighscoreEntry[]\n}\n\n/** Color configuration using CSS custom properties */\nexport interface SnakeGameColors {\n  /** Snake body color - default: 'var(--foreground)' */\n  snake: string\n  /** Food color - default: 'var(--primary)' */\n  food: string\n  /** Canvas background - default: 'var(--muted)' */\n  background: string\n}\n\n/** Grid configuration */\nexport interface SnakeGameGrid {\n  /** Grid size (cells per side) - default: 20 */\n  size: number\n}\n\n/** Physics/speed configuration */\nexport interface SnakeGamePhysics {\n  /** Initial game speed in ms per move - default: 150 */\n  initialSpeed: number\n  /** Speed decrease per food eaten (faster) - default: 2 */\n  speedIncrement: number\n  /** Minimum speed cap in ms - default: 50 */\n  minSpeed: number\n}\n\n/** Scoring configuration */\nexport interface SnakeGameScoring {\n  /** Points per food eaten - default: 1 */\n  pointsPerFood: number\n}\n\n/** Storage configuration */\nexport interface SnakeGameStorage {\n  /** localStorage key for high scores */\n  storageKey: string\n  /** Maximum high scores to keep */\n  maxHighscores: number\n}\n\n/** Complete configuration object */\nexport interface SnakeGameConfig {\n  colors: SnakeGameColors\n  grid: SnakeGameGrid\n  physics: SnakeGamePhysics\n  scoring: SnakeGameScoring\n  storage: SnakeGameStorage\n}\n\n/** Props for the SnakeGame component */\nexport interface SnakeGameProps {\n  /** Partial config overrides (deep merged with defaults) */\n  config?: DeepPartial<SnakeGameConfig>\n  /** Called when game ends */\n  onGameEnd?: (result: GameEndResult) => void\n  /** Called when score updates */\n  onScoreChange?: (score: number) => void\n  /** Called when game state changes */\n  onStateChange?: (state: GameState) => void\n  /** Additional container className */\n  className?: string\n  /** Show built-in UI controls - default: true */\n  showControls?: boolean\n  /** Show high scores list - default: true */\n  showHighscores?: boolean\n}\n\n/** Game end result passed to onGameEnd callback */\nexport interface GameEndResult {\n  score: number\n  highscores: HighscoreEntry[]\n  snakeLength: number\n}\n\n/** Canvas dimensions */\nexport interface CanvasDimensions {\n  size: number\n  cellSize: number\n  dpr: number\n}\n\n/** Deep partial utility type */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/snake-game/config.ts",
      "content": "import type { SnakeGameConfig, SnakeGameColors } from './types'\n\n/** Theme-aware default colors using CSS variables */\nexport const DEFAULT_COLORS: SnakeGameColors = {\n  snake: 'var(--foreground)',\n  food: 'var(--primary)',\n  background: 'var(--muted)',\n}\n\n/** Complete default configuration */\nexport const DEFAULT_CONFIG: SnakeGameConfig = {\n  colors: DEFAULT_COLORS,\n  grid: {\n    size: 20,\n  },\n  physics: {\n    initialSpeed: 150,\n    speedIncrement: 2,\n    minSpeed: 50,\n  },\n  scoring: {\n    pointsPerFood: 1,\n  },\n  storage: {\n    storageKey: 'snake-highscores',\n    maxHighscores: 4,\n  },\n}\n\n/** Game constants (not configurable) */\nexport const GAME_CONSTANTS = {\n  /** Initial snake length */\n  INITIAL_SNAKE_LENGTH: 3,\n  /** Minimum swipe distance for touch controls */\n  MIN_SWIPE_DISTANCE: 30,\n  /** System font stack for canvas text */\n  FONT_FAMILY: 'system-ui, -apple-system, sans-serif',\n} as const\n\n/** Keyboard bindings */\nexport const KEY_BINDINGS = {\n  UP: ['ArrowUp', 'KeyW', 'w', 'W'] as readonly string[],\n  DOWN: ['ArrowDown', 'KeyS', 's', 'S'] as readonly string[],\n  LEFT: ['ArrowLeft', 'KeyA', 'a', 'A'] as readonly string[],\n  RIGHT: ['ArrowRight', 'KeyD', 'd', 'D'] as readonly string[],\n  PAUSE: ['Escape', 'KeyP', 'p', 'P'] as readonly string[],\n  START: ['Space', ' '] as readonly string[],\n} as const\n\n/** Direction vectors for movement */\nexport const DIRECTION_VECTORS = {\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n  LEFT: { x: -1, y: 0 },\n  RIGHT: { x: 1, y: 0 },\n} as const\n\n/** Opposite directions (for preventing 180° turns) */\nexport const OPPOSITE_DIRECTIONS = {\n  UP: 'DOWN',\n  DOWN: 'UP',\n  LEFT: 'RIGHT',\n  RIGHT: 'LEFT',\n} as const\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/snake-game/utils.ts",
      "content": "import type {\n  Position,\n  SnakeGameConfig,\n  DeepPartial,\n  HighscoreEntry,\n} from './types'\nimport { GAME_CONSTANTS } from './config'\n\n/**\n * Deep merge configuration objects\n * @param base - Base configuration\n * @param overrides - Partial overrides to merge\n * @returns Merged configuration\n */\nexport function mergeConfig(\n  base: SnakeGameConfig,\n  overrides?: DeepPartial<SnakeGameConfig>\n): SnakeGameConfig {\n  if (!overrides) return base\n\n  return {\n    colors: { ...base.colors, ...overrides.colors },\n    grid: { ...base.grid, ...overrides.grid },\n    physics: { ...base.physics, ...overrides.physics },\n    scoring: { ...base.scoring, ...overrides.scoring },\n    storage: { ...base.storage, ...overrides.storage },\n  }\n}\n\n/**\n * Create initial snake at center of grid\n * @param gridSize - Size of the grid\n * @returns Array of positions for initial snake\n */\nexport function createInitialSnake(gridSize: number): Position[] {\n  const y = Math.floor(gridSize / 2)\n  const headX = Math.floor(gridSize / 2)\n\n  return Array.from({ length: GAME_CONSTANTS.INITIAL_SNAKE_LENGTH }, (_, i) => ({\n    x: headX - i,\n    y,\n  }))\n}\n\n/**\n * Generate food position that doesn't overlap with snake\n * @param snake - Current snake segments\n * @param gridSize - Size of the grid\n * @returns New food position\n */\nexport function generateFood(snake: Position[], gridSize: number): Position {\n  let newFood: Position\n  do {\n    newFood = {\n      x: Math.floor(Math.random() * gridSize),\n      y: Math.floor(Math.random() * gridSize),\n    }\n  } while (snake.some((s) => s.x === newFood.x && s.y === newFood.y))\n  return newFood\n}\n\n/**\n * Check if two positions are equal\n * @param a - First position\n * @param b - Second position\n * @returns True if positions match\n */\nexport function positionsEqual(a: Position, b: Position): boolean {\n  return a.x === b.x && a.y === b.y\n}\n\n/**\n * Check if position is within grid bounds\n * @param pos - Position to check\n * @param gridSize - Size of the grid\n * @returns True if within bounds\n */\nexport function isWithinBounds(pos: Position, gridSize: number): boolean {\n  return pos.x >= 0 && pos.x < gridSize && pos.y >= 0 && pos.y < gridSize\n}\n\n/**\n * Check if snake collides with itself\n * @param snake - Snake segments (head is first element)\n * @returns True if head collides with body\n */\nexport function checkSelfCollision(snake: Position[]): boolean {\n  const head = snake[0]\n  return snake.slice(1).some((segment) => positionsEqual(head, segment))\n}\n\n/**\n * Resolve CSS variable to actual color value\n * @param color - Color string (may contain var())\n * @param element - DOM element to get computed styles from\n * @returns Resolved color value\n */\nexport function resolveCssColor(color: string, element: HTMLElement): string {\n  if (!color.includes('var(')) return color\n\n  const computed = getComputedStyle(element)\n  const varMatch = color.match(/var\\((--[^)]+)\\)/)\n\n  if (varMatch) {\n    const varName = varMatch[1]\n    const resolved = computed.getPropertyValue(varName).trim()\n    return resolved || color\n  }\n\n  return color\n}\n\n/**\n * Format date for high score display\n * @param date - Date to format\n * @returns Formatted date string\n */\nexport function formatHighscoreDate(date: Date = new Date()): string {\n  return date.toLocaleDateString('en-US', {\n    month: 'short',\n    day: 'numeric',\n  })\n}\n\n/** Storage utilities for localStorage operations */\nexport const storage = {\n  /**\n   * Get high scores from localStorage\n   * @param key - Storage key\n   * @returns Array of high score entries\n   */\n  getHighscores(key: string): HighscoreEntry[] {\n    if (typeof window === 'undefined') return []\n    try {\n      const stored = localStorage.getItem(key)\n      return stored ? JSON.parse(stored) : []\n    } catch {\n      return []\n    }\n  },\n\n  /**\n   * Save high scores to localStorage\n   * @param key - Storage key\n   * @param scores - High score entries to save\n   */\n  setHighscores(key: string, scores: HighscoreEntry[]): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.setItem(key, JSON.stringify(scores))\n    } catch {\n      // Storage full or disabled - silently fail\n    }\n  },\n\n  /**\n   * Add a new high score entry\n   * @param key - Storage key\n   * @param score - Score to add\n   * @param maxEntries - Maximum entries to keep\n   * @returns Updated high scores array\n   */\n  addHighscore(\n    key: string,\n    score: number,\n    maxEntries: number\n  ): HighscoreEntry[] {\n    const current = storage.getHighscores(key)\n    const newEntry: HighscoreEntry = {\n      score,\n      date: formatHighscoreDate(),\n    }\n\n    const updated = [...current, newEntry]\n      .sort((a, b) => b.score - a.score)\n      .slice(0, maxEntries)\n\n    storage.setHighscores(key, updated)\n    return updated\n  },\n}\n\n/**\n * Calculate game speed based on score\n * @param initialSpeed - Starting speed in ms\n * @param speedIncrement - Speed decrease per point\n * @param minSpeed - Minimum speed cap\n * @param score - Current score\n * @returns Speed in ms\n */\nexport function calculateSpeed(\n  initialSpeed: number,\n  speedIncrement: number,\n  minSpeed: number,\n  score: number\n): number {\n  return Math.max(minSpeed, initialSpeed - score * speedIncrement)\n}\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/snake-game/use-snake-game.ts",
      "content": "'use client'\n\nimport * as React from 'react'\nimport type {\n  GameState,\n  GameSnapshot,\n  GameEndResult,\n  SnakeGameConfig,\n  Direction,\n  Position,\n  HighscoreEntry,\n} from './types'\nimport {\n  createInitialSnake,\n  generateFood,\n  storage,\n} from './utils'\n\ninterface UseSnakeGameOptions {\n  config: SnakeGameConfig\n  onGameEnd?: (result: GameEndResult) => void\n  onScoreChange?: (score: number) => void\n  onStateChange?: (state: GameState) => void\n}\n\ninterface UseSnakeGameReturn {\n  gameState: GameState\n  snapshot: GameSnapshot\n  startGame: () => void\n  pauseGame: () => void\n  resumeGame: () => void\n  resetGame: () => void\n  setDirection: (direction: Direction) => void\n}\n\n/**\n * Custom hook for snake game logic.\n * Mirrors the proven working implementation from the sidebar snake game.\n */\nexport function useSnakeGame(options: UseSnakeGameOptions): UseSnakeGameReturn {\n  const { config, onGameEnd, onScoreChange, onStateChange } = options\n  const gridSize = config.grid.size\n\n  // Use separate isPlaying/gameOver booleans like original\n  const [isPlaying, setIsPlaying] = React.useState(false)\n  const [gameOver, setGameOver] = React.useState(false)\n  const [snake, setSnake] = React.useState<Position[]>(() =>\n    createInitialSnake(gridSize)\n  )\n  const [food, setFood] = React.useState<Position>(() =>\n    generateFood(createInitialSnake(gridSize), gridSize)\n  )\n  const [direction, setDirectionState] = React.useState<Direction>('RIGHT')\n  const [score, setScore] = React.useState(0)\n  const [highscores, setHighscores] = React.useState<HighscoreEntry[]>([])\n\n  const directionRef = React.useRef<Direction>(direction)\n  const lastMovedDirectionRef = React.useRef<Direction>(direction)\n\n  // Compute game state from booleans\n  const gameState: GameState = gameOver\n    ? 'gameOver'\n    : isPlaying\n      ? 'playing'\n      : 'idle'\n\n  // Load high scores on mount\n  React.useEffect(() => {\n    const loaded = storage.getHighscores(config.storage.storageKey)\n    setHighscores(loaded)\n  }, [config.storage.storageKey])\n\n  // Sync direction ref\n  React.useEffect(() => {\n    directionRef.current = direction\n  }, [direction])\n\n  // Notify state changes\n  React.useEffect(() => {\n    onStateChange?.(gameState)\n  }, [gameState, onStateChange])\n\n  // Notify score changes\n  React.useEffect(() => {\n    onScoreChange?.(score)\n  }, [score, onScoreChange])\n\n  // Handle game over and save highscore\n  React.useEffect(() => {\n    if (gameOver && score > 0) {\n      const updated = storage.addHighscore(\n        config.storage.storageKey,\n        score,\n        config.storage.maxHighscores\n      )\n      setHighscores(updated)\n\n      onGameEnd?.({\n        score,\n        highscores: updated,\n        snakeLength: snake.length,\n      })\n    }\n  }, [\n    gameOver,\n    score,\n    snake.length,\n    config.storage.storageKey,\n    config.storage.maxHighscores,\n    onGameEnd,\n  ])\n\n  // Reset game state - exactly like original\n  const resetGame = React.useCallback(() => {\n    const initialSnake = createInitialSnake(gridSize)\n    setSnake(initialSnake)\n    setFood(generateFood(initialSnake, gridSize))\n    setDirectionState('RIGHT')\n    directionRef.current = 'RIGHT'\n    lastMovedDirectionRef.current = 'RIGHT'\n    setGameOver(false)\n    setScore(0)\n    setIsPlaying(true)\n  }, [gridSize])\n\n  const startGame = resetGame\n\n  const pauseGame = React.useCallback(() => {\n    if (isPlaying && !gameOver) {\n      setIsPlaying(false)\n    }\n  }, [isPlaying, gameOver])\n\n  const resumeGame = React.useCallback(() => {\n    if (!isPlaying && !gameOver) {\n      setIsPlaying(true)\n    }\n  }, [isPlaying, gameOver])\n\n  // Set direction (with 180° turn prevention)\n  const setDirection = React.useCallback((newDirection: Direction) => {\n    const lastMoved = lastMovedDirectionRef.current\n\n    // Prevent 180° turns\n    const opposites: Record<Direction, Direction> = {\n      UP: 'DOWN',\n      DOWN: 'UP',\n      LEFT: 'RIGHT',\n      RIGHT: 'LEFT',\n    }\n\n    if (opposites[newDirection] !== lastMoved) {\n      setDirectionState(newDirection)\n    }\n  }, [])\n\n  // Game loop - exactly like original\n  React.useEffect(() => {\n    if (!isPlaying || gameOver) return\n\n    const moveSnake = () => {\n      setSnake((prev) => {\n        const head = { ...prev[0] }\n        const dir = directionRef.current\n\n        // Update last moved direction BEFORE moving\n        lastMovedDirectionRef.current = dir\n\n        // Move head\n        if (dir === 'UP') head.y -= 1\n        if (dir === 'DOWN') head.y += 1\n        if (dir === 'LEFT') head.x -= 1\n        if (dir === 'RIGHT') head.x += 1\n\n        // Check wall collision\n        if (\n          head.x < 0 ||\n          head.x >= gridSize ||\n          head.y < 0 ||\n          head.y >= gridSize\n        ) {\n          setGameOver(true)\n          setIsPlaying(false)\n          return prev\n        }\n\n        // Check self collision\n        if (prev.some((s) => s.x === head.x && s.y === head.y)) {\n          setGameOver(true)\n          setIsPlaying(false)\n          return prev\n        }\n\n        const newSnake = [head, ...prev]\n\n        // Check food collision\n        if (head.x === food.x && head.y === food.y) {\n          setScore((s) => s + config.scoring.pointsPerFood)\n          setFood(generateFood(newSnake, gridSize))\n        } else {\n          newSnake.pop()\n        }\n\n        return newSnake\n      })\n    }\n\n    const interval = setInterval(moveSnake, config.physics.initialSpeed)\n    return () => clearInterval(interval)\n  }, [isPlaying, gameOver, food, gridSize, config.physics.initialSpeed, config.scoring.pointsPerFood])\n\n  // Create snapshot\n  const snapshot: GameSnapshot = {\n    state: gameState,\n    snake: {\n      segments: snake,\n      direction,\n      nextDirection: direction,\n    },\n    food: {\n      position: food,\n    },\n    score,\n    highscores,\n  }\n\n  return {\n    gameState,\n    snapshot,\n    startGame,\n    pauseGame,\n    resumeGame,\n    resetGame,\n    setDirection,\n  }\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "hooks/use-local-storage.ts",
      "content": "'use client'\n\nimport * as React from 'react'\n\n/**\n * React hook for syncing state with localStorage.\n * Provides automatic serialization, SSR safety, and cross-tab sync.\n *\n * @example\n * ```tsx\n * const [value, setValue] = useLocalStorage('my-key', 'default')\n * ```\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] {\n  // Get initial value from localStorage or use provided initial value\n  const getStoredValue = React.useCallback((): T => {\n    if (typeof window === 'undefined') {\n      return initialValue\n    }\n\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? (JSON.parse(item) as T) : initialValue\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error)\n      return initialValue\n    }\n  }, [key, initialValue])\n\n  const [storedValue, setStoredValue] = React.useState<T>(getStoredValue)\n\n  // Update localStorage when state changes\n  const setValue: React.Dispatch<React.SetStateAction<T>> = React.useCallback(\n    (value) => {\n      try {\n        const valueToStore =\n          value instanceof Function ? value(storedValue) : value\n\n        setStoredValue(valueToStore)\n\n        if (typeof window !== 'undefined') {\n          window.localStorage.setItem(key, JSON.stringify(valueToStore))\n        }\n      } catch (error) {\n        console.warn(`Error setting localStorage key \"${key}\":`, error)\n      }\n    },\n    [key, storedValue]\n  )\n\n  // Sync with localStorage changes from other tabs\n  React.useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key && event.newValue !== null) {\n        try {\n          setStoredValue(JSON.parse(event.newValue) as T)\n        } catch (error) {\n          console.warn(`Error parsing localStorage change for \"${key}\":`, error)\n        }\n      }\n    }\n\n    window.addEventListener('storage', handleStorageChange)\n    return () => window.removeEventListener('storage', handleStorageChange)\n  }, [key])\n\n  return [storedValue, setValue]\n}\n\n/**\n * Simple localStorage helpers for non-reactive access\n */\nexport const storage = {\n  get<T>(key: string, defaultValue: T): T {\n    if (typeof window === 'undefined') return defaultValue\n    try {\n      const item = localStorage.getItem(key)\n      return item ? (JSON.parse(item) as T) : defaultValue\n    } catch {\n      return defaultValue\n    }\n  },\n\n  set<T>(key: string, value: T): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.setItem(key, JSON.stringify(value))\n    } catch {\n      // Silently fail (e.g., quota exceeded)\n    }\n  },\n\n  remove(key: string): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.removeItem(key)\n    } catch {\n      // Silently fail\n    }\n  },\n}\n\n",
      "type": "registry:hook"
    }
  ]
}