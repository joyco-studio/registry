{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "brick-breaker",
  "type": "registry:component",
  "title": "Brick Breaker",
  "description": "A fully-featured brick breaker game with multiple levels, brick types, and proper collision physics.",
  "files": [
    {
      "path": "registry/joyco/blocks/brick-breaker/index.ts",
      "content": "// Component\nexport { BrickBreaker } from './brick-breaker'\n\n// Hook (for advanced usage)\nexport { useBrickBreaker } from './use-brick-breaker'\n\n// UI Components (for custom layouts)\nexport {\n  useBrickBreakerUI,\n  BrickBreakerUIProvider,\n  BrickBreakerCanvas,\n  BrickBreakerScore,\n  BrickBreakerHighScore,\n  BrickBreakerLevel,\n  BrickBreakerLives,\n  BrickBreakerHUD,\n  BrickBreakerOverlay,\n  BrickBreakerTitle,\n  BrickBreakerMessage,\n  BrickBreakerHint,\n  BrickBreakerScoreDisplay,\n  BrickBreakerActionButton,\n  BrickBreakerDefaultUI,\n} from './ui'\n\n// Types\nexport type {\n  // Core game types\n  GameState,\n  GameSnapshot,\n  GameEndResult,\n\n  // Geometry\n  Vector2D,\n  Bounds,\n  CollisionSide,\n  CollisionResult,\n\n  // Game objects\n  Brick,\n  BrickType,\n  BrickDefinition,\n  Ball,\n  Paddle,\n\n  // Levels\n  Level,\n\n  // Configuration\n  BrickBreakerConfig,\n  BrickBreakerProps,\n  BrickBreakerColors,\n  BrickBreakerLayout,\n  BrickBreakerSizing,\n  BrickBreakerPhysics,\n  BrickBreakerScoring,\n  BrickBreakerGameplay,\n  BrickBreakerEffects,\n  BrickBreakerStorage,\n\n  // Utilities\n  DeepPartial,\n  CanvasDimensions,\n} from './types'\n\n// Config presets\nexport {\n  DEFAULT_CONFIG,\n  DEFAULT_COLORS,\n  GAME_CONSTANTS,\n  KEY_BINDINGS,\n  BRICK_VISUALS,\n} from './config'\n\n// Level utilities\nexport {\n  DEFAULT_LEVELS,\n  createLevelFromPattern,\n  generateRandomLevel,\n  getBrickHealth,\n  isLevelCompletable,\n  countDestructibleBricks,\n} from './levels'\n\n// Utility functions\nexport {\n  mergeConfig,\n  detectCollision,\n  resolveBallBrickCollision,\n  resolveBallPaddleCollision,\n  resolveCssColor,\n  formatScore,\n  normalize,\n  magnitude,\n  scale,\n  add,\n  subtract,\n  dot,\n  reflect,\n  clamp,\n  lerp,\n  storage,\n} from './utils'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/brick-breaker.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\nimport type {\n  BrickBreakerProps,\n  BrickBreakerConfig,\n  CanvasDimensions,\n  GameSnapshot,\n  Brick,\n  BrickType,\n} from './types'\nimport {\n  DEFAULT_CONFIG,\n  GAME_CONSTANTS,\n  KEY_BINDINGS,\n  BRICK_VISUALS,\n} from './config'\nimport { DEFAULT_LEVELS } from './levels'\nimport { useBrickBreaker } from './use-brick-breaker'\nimport { mergeConfig, resolveCssColor } from './utils'\nimport { BrickBreakerUIProvider, BrickBreakerDefaultUI, BrickBreakerCanvas } from './ui'\n\n/**\n * Draw rounded rectangle\n */\nfunction drawRoundedRect(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number\n): void {\n  ctx.beginPath()\n  ctx.moveTo(x + radius, y)\n  ctx.lineTo(x + width - radius, y)\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius)\n  ctx.lineTo(x + width, y + height - radius)\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)\n  ctx.lineTo(x + radius, y + height)\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius)\n  ctx.lineTo(x, y + radius)\n  ctx.quadraticCurveTo(x, y, x + radius, y)\n  ctx.closePath()\n  ctx.fill()\n}\n\n/**\n * Draw brick with type-specific patterns\n */\nfunction drawBrick(\n  ctx: CanvasRenderingContext2D,\n  brick: Brick,\n  baseColor: string,\n  borderRadius: number\n): void {\n  const { x, y, width, height } = brick.bounds\n  const visual = BRICK_VISUALS[brick.type]\n\n  ctx.globalAlpha = visual.opacity\n\n  // Health-based opacity for damaged bricks\n  if (brick.maxHealth > 1 && brick.health < brick.maxHealth) {\n    const healthRatio = brick.health / brick.maxHealth\n    ctx.globalAlpha *= 0.5 + healthRatio * 0.5\n  }\n\n  ctx.fillStyle = baseColor\n  drawRoundedRect(ctx, x, y, width, height, borderRadius)\n\n  // Draw pattern overlay for special bricks\n  if (visual.pattern && brick.type !== 'normal') {\n    ctx.globalAlpha = 0.15\n\n    if (visual.pattern === 'diagonal') {\n      // Strong brick: diagonal lines\n      ctx.strokeStyle = baseColor\n      ctx.lineWidth = 1\n      const step = 6\n      for (let i = -height; i < width + height; i += step) {\n        ctx.beginPath()\n        ctx.moveTo(x + i, y)\n        ctx.lineTo(x + i + height, y + height)\n        ctx.stroke()\n      }\n    } else if (visual.pattern === 'cross') {\n      // Metal brick: cross pattern\n      ctx.strokeStyle = baseColor\n      ctx.lineWidth = 2\n      ctx.beginPath()\n      ctx.moveTo(x + width * 0.2, y + height * 0.5)\n      ctx.lineTo(x + width * 0.8, y + height * 0.5)\n      ctx.moveTo(x + width * 0.5, y + height * 0.2)\n      ctx.lineTo(x + width * 0.5, y + height * 0.8)\n      ctx.stroke()\n    }\n  }\n\n  ctx.globalAlpha = 1\n}\n\n/**\n * Render game to canvas\n */\nfunction renderGame(\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  snapshot: GameSnapshot,\n  config: BrickBreakerConfig,\n  dimensions: CanvasDimensions\n): void {\n  const { width, height, dpr } = dimensions\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0)\n  ctx.scale(dpr, dpr)\n  ctx.clearRect(0, 0, width, height)\n\n  // Resolve colors\n  const bgColor = resolveCssColor(config.colors.background, canvas)\n  const paddleColor = resolveCssColor(config.colors.paddle, canvas)\n  const ballColor = resolveCssColor(config.colors.ball, canvas)\n  const trailColor = resolveCssColor(config.colors.ballTrail, canvas)\n  const textColor = resolveCssColor(config.colors.text, canvas)\n  const textMutedColor = resolveCssColor(config.colors.textMuted, canvas)\n\n  const brickColors: Record<BrickType, string> = {\n    normal: resolveCssColor(config.colors.bricks.normal, canvas),\n    strong: resolveCssColor(config.colors.bricks.strong, canvas),\n    metal: resolveCssColor(config.colors.bricks.metal, canvas),\n    indestructible: resolveCssColor(\n      config.colors.bricks.indestructible,\n      canvas\n    ),\n  }\n\n  // Background\n  ctx.fillStyle = bgColor\n  ctx.fillRect(0, 0, width, height)\n\n  // Draw bricks\n  const now = Date.now()\n  for (const brick of snapshot.bricks) {\n    if (brick.destroyed) {\n      // Fade out animation\n      if (brick.destroyedAt) {\n        const elapsed = now - brick.destroyedAt\n        const progress = elapsed / config.effects.destroyAnimationDuration\n        if (progress < 1) {\n          ctx.globalAlpha = 1 - progress\n          drawBrick(\n            ctx,\n            brick,\n            brickColors[brick.type],\n            config.layout.brickBorderRadius\n          )\n          ctx.globalAlpha = 1\n        }\n      }\n      continue\n    }\n\n    drawBrick(\n      ctx,\n      brick,\n      brickColors[brick.type],\n      config.layout.brickBorderRadius\n    )\n  }\n\n  // Helper to draw ball based on style\n  const drawBall = (\n    x: number,\n    y: number,\n    radius: number,\n    color: string,\n    alpha = 1\n  ) => {\n    ctx.globalAlpha = alpha\n    ctx.fillStyle = color\n\n    if (config.layout.ballStyle === 'custom' && config.layout.renderBall) {\n      config.layout.renderBall(ctx, x, y, radius, color)\n    } else if (config.layout.ballStyle === 'square') {\n      const size = radius * 2\n      ctx.fillRect(x - radius, y - radius, size, size)\n    } else {\n      ctx.beginPath()\n      ctx.arc(x, y, radius, 0, Math.PI * 2)\n      ctx.fill()\n    }\n\n    ctx.globalAlpha = 1\n  }\n\n  // Draw ball trail\n  if (config.effects.showTrail && snapshot.ball.trail.length > 0) {\n    for (let i = 0; i < snapshot.ball.trail.length; i++) {\n      const pos = snapshot.ball.trail[i]\n      const progress = (i + 1) / snapshot.ball.trail.length\n      const opacity = progress * config.effects.trailOpacity\n      const trailRadius = snapshot.ball.radius * (0.3 + 0.7 * progress)\n\n      drawBall(pos.x, pos.y, trailRadius, trailColor, opacity)\n    }\n  }\n\n  // Draw ball\n  drawBall(\n    snapshot.ball.position.x,\n    snapshot.ball.position.y,\n    snapshot.ball.radius,\n    ballColor\n  )\n\n  // Draw paddle\n  ctx.fillStyle = paddleColor\n  const paddleRadius =\n    config.layout.paddleBorderRadius === 'auto'\n      ? snapshot.paddle.bounds.height / 2\n      : config.layout.paddleBorderRadius\n  drawRoundedRect(\n    ctx,\n    snapshot.paddle.bounds.x,\n    snapshot.paddle.bounds.y,\n    snapshot.paddle.bounds.width,\n    snapshot.paddle.bounds.height,\n    paddleRadius\n  )\n\n  // Note: HUD and overlays are now rendered as React components via children\n}\n\n/**\n * Brick Breaker Game Component\n */\n/** Input mode - once locked, other input types are ignored for movement */\ntype InputMode = 'none' | 'keyboard' | 'pointer'\n\nexport function BrickBreaker({\n  config: configOverrides,\n  levels: customLevels,\n  startLevel = 1,\n  onGameEnd,\n  onScoreChange,\n  onStateChange,\n  onLevelChange,\n  className,\n  autoFocus = true,\n  showFocusRing = true,\n  children,\n}: BrickBreakerProps & { children?: React.ReactNode }) {\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  const canvasWrapperRef = React.useRef<HTMLDivElement>(null)\n  const canvasRef = React.useRef<HTMLCanvasElement>(null)\n  const [dimensions, setDimensions] = React.useState<CanvasDimensions>({\n    width: 400,\n    height: 300,\n    dpr: 1,\n  })\n  const [theme, setTheme] = React.useState('')\n\n  // Input mode locking - prevents keyboard/mouse conflicts\n  const inputModeRef = React.useRef<InputMode>('none')\n\n  const config = React.useMemo<BrickBreakerConfig>(\n    () => mergeConfig(DEFAULT_CONFIG, configOverrides),\n    [configOverrides]\n  )\n\n  const levels = customLevels || DEFAULT_LEVELS\n\n  const {\n    snapshot,\n    startGame,\n    pauseGame,\n    resumeGame,\n    resetGame,\n    nextLevel,\n    movePaddle,\n    setPaddlePosition,\n    launchBall,\n  } = useBrickBreaker({\n    config,\n    levels,\n    startLevel,\n    canvasDimensions: dimensions,\n    onGameEnd,\n    onScoreChange,\n    onStateChange,\n    onLevelChange,\n  })\n\n  // Reset input mode when game is not playing\n  React.useEffect(() => {\n    if (snapshot.state !== 'playing') {\n      inputModeRef.current = 'none'\n    }\n  }, [snapshot.state])\n\n  // Responsive sizing - follows container width, maintains aspect ratio\n  React.useEffect(() => {\n    const wrapper = canvasWrapperRef.current\n    if (!wrapper) return\n\n    const updateSize = () => {\n      const rect = wrapper.getBoundingClientRect()\n      const wrapperWidth = Math.max(rect.width, 1)\n      const wrapperHeight = Math.max(rect.height, 1)\n      const dpr = window.devicePixelRatio || 1\n\n      // Calculate dimensions that fit within wrapper while maintaining aspect ratio\n      const heightFromWidth = wrapperWidth / GAME_CONSTANTS.ASPECT_RATIO\n      const widthFromHeight = wrapperHeight * GAME_CONSTANTS.ASPECT_RATIO\n\n      let width: number\n      let height: number\n\n      if (heightFromWidth <= wrapperHeight) {\n        // Width is the constraint - use full width\n        width = wrapperWidth\n        height = heightFromWidth\n      } else {\n        // Height is the constraint - use full height\n        width = widthFromHeight\n        height = wrapperHeight\n      }\n\n      setDimensions({ width, height, dpr })\n    }\n\n    updateSize()\n    const resizeObserver = new ResizeObserver(updateSize)\n    resizeObserver.observe(wrapper)\n\n    return () => resizeObserver.disconnect()\n  }, [])\n\n  // Theme changes\n  React.useEffect(() => {\n    const html = document.documentElement\n    setTheme(html.className)\n\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.attributeName === 'class') {\n          setTheme(html.className)\n        }\n      }\n    })\n\n    observer.observe(html, { attributes: true, attributeFilter: ['class'] })\n    return () => observer.disconnect()\n  }, [])\n\n  // Render\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext('2d')\n    if (!ctx) return\n\n    canvas.width = dimensions.width * dimensions.dpr\n    canvas.height = dimensions.height * dimensions.dpr\n\n    renderGame(ctx, canvas, snapshot, config, dimensions)\n  }, [snapshot, config, dimensions, theme])\n\n  // Keyboard controls\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const code = e.code\n\n      // Movement keys - switch to keyboard mode (allows taking over from pointer)\n      if (\n        KEY_BINDINGS.LEFT.includes(code) ||\n        KEY_BINDINGS.RIGHT.includes(code)\n      ) {\n        // Switch to keyboard mode - keyboard can always take over\n        inputModeRef.current = 'keyboard'\n        e.preventDefault()\n\n        if (KEY_BINDINGS.LEFT.includes(code)) {\n          movePaddle('left')\n        } else {\n          movePaddle('right')\n        }\n        return\n      }\n\n      // Action keys (always allowed regardless of input mode)\n      if (KEY_BINDINGS.START.includes(code)) {\n        e.preventDefault()\n        if (snapshot.state === 'idle') {\n          startGame()\n        } else if (snapshot.state === 'paused') {\n          resumeGame()\n        } else if (snapshot.state === 'playing') {\n          if (!snapshot.ball.isLaunched) {\n            launchBall()\n          } else {\n            pauseGame()\n          }\n        } else if (snapshot.state === 'levelComplete') {\n          nextLevel()\n        }\n      }\n\n      if (KEY_BINDINGS.PAUSE.includes(code)) {\n        e.preventDefault()\n        if (snapshot.state === 'playing') {\n          pauseGame()\n        } else if (snapshot.state === 'paused') {\n          resumeGame()\n        }\n      }\n\n      if (KEY_BINDINGS.RESTART.includes(code)) {\n        if (snapshot.state === 'won' || snapshot.state === 'lost') {\n          resetGame()\n          setTimeout(startGame, 100)\n        }\n      }\n    }\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n      const code = e.code\n      if (\n        KEY_BINDINGS.LEFT.includes(code) ||\n        KEY_BINDINGS.RIGHT.includes(code)\n      ) {\n        // Only respond if in keyboard mode\n        if (inputModeRef.current === 'keyboard') {\n          movePaddle('none')\n          // Reset so pointer can take over\n          inputModeRef.current = 'none'\n        }\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    window.addEventListener('keyup', handleKeyUp)\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown)\n      window.removeEventListener('keyup', handleKeyUp)\n    }\n  }, [\n    snapshot.state,\n    snapshot.ball.isLaunched,\n    startGame,\n    pauseGame,\n    resumeGame,\n    resetGame,\n    nextLevel,\n    movePaddle,\n    launchBall,\n  ])\n\n  // Mouse controls\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (snapshot.state !== 'playing') return\n\n      // Mouse can take over from null or pointer mode, but not keyboard\n      if (inputModeRef.current === 'keyboard') return\n\n      inputModeRef.current = 'pointer'\n\n      const rect = canvas.getBoundingClientRect()\n      const x = ((e.clientX - rect.left) / rect.width) * dimensions.width\n      setPaddlePosition(x)\n    }\n\n    const handleClick = () => {\n      // Click actions are always allowed (start, launch, resume, etc.)\n      if (snapshot.state === 'idle') {\n        startGame()\n      } else if (snapshot.state === 'paused') {\n        resumeGame()\n      } else if (snapshot.state === 'playing' && !snapshot.ball.isLaunched) {\n        launchBall()\n      } else if (snapshot.state === 'levelComplete') {\n        nextLevel()\n      } else if (snapshot.state === 'won' || snapshot.state === 'lost') {\n        resetGame()\n        setTimeout(startGame, 100)\n      }\n    }\n\n    const handleMouseLeave = () => {\n      // Reset pointer mode when mouse leaves canvas\n      if (inputModeRef.current === 'pointer') {\n        inputModeRef.current = 'none'\n      }\n    }\n\n    canvas.addEventListener('mousemove', handleMouseMove)\n    canvas.addEventListener('click', handleClick)\n    canvas.addEventListener('mouseleave', handleMouseLeave)\n\n    return () => {\n      canvas.removeEventListener('mousemove', handleMouseMove)\n      canvas.removeEventListener('click', handleClick)\n      canvas.removeEventListener('mouseleave', handleMouseLeave)\n    }\n  }, [\n    snapshot.state,\n    snapshot.ball.isLaunched,\n    dimensions,\n    startGame,\n    resumeGame,\n    resetGame,\n    nextLevel,\n    setPaddlePosition,\n    launchBall,\n  ])\n\n  // Touch controls\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const handleTouchStart = (e: TouchEvent) => {\n      e.preventDefault()\n\n      // Touch always takes over input mode\n      inputModeRef.current = 'pointer'\n\n      // Position paddle immediately on touch\n      if (snapshot.state === 'playing' && e.touches[0]) {\n        const touch = e.touches[0]\n        const rect = canvas.getBoundingClientRect()\n        const x = ((touch.clientX - rect.left) / rect.width) * dimensions.width\n        setPaddlePosition(x)\n      }\n\n      // Touch actions (start, launch, etc.)\n      if (snapshot.state === 'idle') {\n        startGame()\n      } else if (snapshot.state === 'paused') {\n        resumeGame()\n      } else if (snapshot.state === 'playing' && !snapshot.ball.isLaunched) {\n        launchBall()\n      } else if (snapshot.state === 'levelComplete') {\n        nextLevel()\n      } else if (snapshot.state === 'won' || snapshot.state === 'lost') {\n        resetGame()\n        setTimeout(startGame, 100)\n      }\n    }\n\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault()\n      if (snapshot.state !== 'playing') return\n      if (!e.touches[0]) return\n\n      const touch = e.touches[0]\n      const rect = canvas.getBoundingClientRect()\n      const x = ((touch.clientX - rect.left) / rect.width) * dimensions.width\n      setPaddlePosition(x)\n    }\n\n    const handleTouchEnd = () => {\n      // Reset input mode when touch ends so keyboard can take over\n      if (inputModeRef.current === 'pointer') {\n        inputModeRef.current = 'none'\n      }\n    }\n\n    canvas.addEventListener('touchstart', handleTouchStart, { passive: false })\n    canvas.addEventListener('touchmove', handleTouchMove, { passive: false })\n    canvas.addEventListener('touchend', handleTouchEnd)\n    canvas.addEventListener('touchcancel', handleTouchEnd)\n\n    return () => {\n      canvas.removeEventListener('touchstart', handleTouchStart)\n      canvas.removeEventListener('touchmove', handleTouchMove)\n      canvas.removeEventListener('touchend', handleTouchEnd)\n      canvas.removeEventListener('touchcancel', handleTouchEnd)\n    }\n  }, [\n    snapshot.state,\n    snapshot.ball.isLaunched,\n    dimensions,\n    startGame,\n    resumeGame,\n    resetGame,\n    nextLevel,\n    setPaddlePosition,\n    launchBall,\n  ])\n\n  // Auto-focus\n  React.useEffect(() => {\n    if (autoFocus) {\n      canvasRef.current?.focus()\n    }\n  }, [autoFocus])\n\n  // Context value for UI components\n  const uiContextValue = React.useMemo(\n    () => ({\n      snapshot,\n      startGame,\n      pauseGame,\n      resumeGame,\n      resetGame,\n      nextLevel,\n    }),\n    [snapshot, startGame, pauseGame, resumeGame, resetGame, nextLevel]\n  )\n\n  // Canvas element to render\n  const canvasElement = (\n    <canvas\n      ref={canvasRef}\n      data-slot=\"brick-breaker-canvas\"\n      className={cn(\n        'block outline-none',\n        showFocusRing && 'focus-visible:ring-ring/50 focus-visible:ring-[3px]'\n      )}\n      style={{\n        width: dimensions.width,\n        height: dimensions.height,\n        imageRendering: 'crisp-edges',\n      }}\n      tabIndex={0}\n      role=\"img\"\n      aria-label={`Brick Breaker - Level ${snapshot.level}, Score: ${snapshot.score}, Lives: ${snapshot.lives}`}\n    />\n  )\n\n  // Check if children contain a BrickBreakerCanvas slot\n  const childArray = React.Children.toArray(children)\n  const hasCanvasSlot = childArray.some(\n    (child) =>\n      React.isValidElement(child) &&\n      (child.type as React.ComponentType)?.displayName === 'BrickBreakerCanvas'\n  )\n\n  // Find overlay components\n  const overlays = childArray.filter(\n    (child) =>\n      React.isValidElement(child) &&\n      (child.type as React.ComponentType)?.displayName === 'BrickBreakerOverlay'\n  )\n\n  // Process children - replace canvas slot with actual canvas\n  const processedChildren = hasCanvasSlot\n    ? childArray.map((child) => {\n        if (\n          React.isValidElement(child) &&\n          (child.type as React.ComponentType)?.displayName === 'BrickBreakerCanvas'\n        ) {\n          // Replace slot with canvas wrapper that takes flex-1\n          return (\n            <div\n              key=\"canvas-wrapper\"\n              ref={canvasWrapperRef}\n              className={cn('relative flex min-h-0 flex-1 items-center justify-center', child.props.className)}\n            >\n              {canvasElement}\n              {/* Overlay goes inside canvas wrapper for proper positioning */}\n              {overlays}\n            </div>\n          )\n        }\n        // Filter out overlays since they're rendered inside canvas wrapper\n        if (\n          React.isValidElement(child) &&\n          (child.type as React.ComponentType)?.displayName === 'BrickBreakerOverlay'\n        ) {\n          return null\n        }\n        return child\n      })\n    : null\n\n  return (\n    <BrickBreakerUIProvider value={uiContextValue}>\n      <div\n        ref={containerRef}\n        data-slot=\"brick-breaker\"\n        data-state={snapshot.state}\n        className={cn('relative flex flex-col', className)}\n      >\n        {hasCanvasSlot ? (\n          // User specified layout with canvas slot\n          processedChildren\n        ) : children ? (\n          // User provided children but no canvas slot - canvas first, then children overlay\n          <>\n            <div ref={canvasWrapperRef} className=\"relative flex min-h-0 flex-1 items-center justify-center\">\n              {canvasElement}\n              {children}\n            </div>\n          </>\n        ) : (\n          // No children - use default UI\n          <>\n            <div ref={canvasWrapperRef} className=\"relative flex min-h-0 flex-1 items-center justify-center\">\n              {canvasElement}\n              <BrickBreakerDefaultUI />\n            </div>\n          </>\n        )}\n\n        <div className=\"sr-only\" aria-live=\"polite\" aria-atomic=\"true\">\n          {snapshot.state === 'won' &&\n            `You won! Final score: ${snapshot.score}`}\n          {snapshot.state === 'lost' && `Game over. Score: ${snapshot.score}`}\n          {snapshot.state === 'levelComplete' &&\n            `Level ${snapshot.level} complete! Score: ${snapshot.score}`}\n        </div>\n      </div>\n    </BrickBreakerUIProvider>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/ui.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\nimport type { GameSnapshot, GameState } from './types'\nimport { formatScore } from './utils'\n\n// ============================================================================\n// Context\n// ============================================================================\n\ninterface BrickBreakerUIContextValue {\n  snapshot: GameSnapshot\n  startGame: () => void\n  pauseGame: () => void\n  resumeGame: () => void\n  resetGame: () => void\n  nextLevel: () => void\n}\n\nconst BrickBreakerUIContext =\n  React.createContext<BrickBreakerUIContextValue | null>(null)\n\nexport function useBrickBreakerUI() {\n  const context = React.useContext(BrickBreakerUIContext)\n  if (!context) {\n    throw new Error(\n      'BrickBreaker UI components must be used within BrickBreakerRoot'\n    )\n  }\n  return context\n}\n\nexport const BrickBreakerUIProvider = BrickBreakerUIContext.Provider\n\n// ============================================================================\n// HUD Components\n// ============================================================================\n\ninterface ScoreProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Show combo multiplier */\n  showCombo?: boolean\n}\n\nexport function BrickBreakerScore({\n  showCombo = true,\n  className,\n  ...props\n}: ScoreProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  return (\n    <div\n      data-slot=\"brick-breaker-score\"\n      className={cn('flex flex-col', className)}\n      {...props}\n    >\n      <span className=\"text-foreground font-semibold tabular-nums\">\n        {formatScore(snapshot.score)}\n      </span>\n      {showCombo && snapshot.combo > 0 && snapshot.state === 'playing' && (\n        <span className=\"text-muted-foreground text-xs tabular-nums\">\n          Ã—{snapshot.combo + 1}\n        </span>\n      )}\n    </div>\n  )\n}\n\ninterface HighScoreProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Label prefix */\n  label?: string\n}\n\nexport function BrickBreakerHighScore({\n  label = 'HI',\n  className,\n  ...props\n}: HighScoreProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  return (\n    <div\n      data-slot=\"brick-breaker-highscore\"\n      className={cn('text-muted-foreground tabular-nums', className)}\n      {...props}\n    >\n      {label} {formatScore(snapshot.highScore)}\n    </div>\n  )\n}\n\ninterface LevelProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Show total levels */\n  showTotal?: boolean\n  /** Label prefix */\n  label?: string\n}\n\nexport function BrickBreakerLevel({\n  showTotal = true,\n  label = 'LVL',\n  className,\n  ...props\n}: LevelProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  return (\n    <div\n      data-slot=\"brick-breaker-level\"\n      className={cn('text-muted-foreground tabular-nums', className)}\n      {...props}\n    >\n      {label} {snapshot.level}\n      {showTotal && `/${snapshot.totalLevels}`}\n    </div>\n  )\n}\n\ninterface LivesProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Render function for each life indicator */\n  renderLife?: (index: number, isActive: boolean) => React.ReactNode\n}\n\nexport function BrickBreakerLives({\n  renderLife,\n  className,\n  ...props\n}: LivesProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  const defaultRenderLife = (index: number) => (\n    <span key={index} className=\"bg-foreground/80 size-2 rounded-sm\" />\n  )\n\n  return (\n    <div\n      data-slot=\"brick-breaker-lives\"\n      className={cn('flex items-center gap-1', className)}\n      {...props}\n    >\n      {Array.from({ length: snapshot.lives }, (_, i) =>\n        renderLife ? renderLife(i, true) : defaultRenderLife(i)\n      )}\n    </div>\n  )\n}\n\n// ============================================================================\n// Canvas Slot - marks where the canvas should render\n// ============================================================================\n\nexport interface BrickBreakerCanvasProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Additional class names for the canvas wrapper */\n  className?: string\n}\n\n/**\n * Slot component that marks where the game canvas should be rendered.\n * Use this to control canvas placement within your layout.\n * Props are passed to the canvas wrapper div.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function BrickBreakerCanvas(props: BrickBreakerCanvasProps) {\n  // This is a marker component - actual canvas is rendered by BrickBreaker\n  // The props are read by BrickBreaker and applied to the canvas wrapper\n  return null\n}\n\n// Internal marker to identify canvas slot\nBrickBreakerCanvas.displayName = 'BrickBreakerCanvas'\n\n// ============================================================================\n// HUD Container\n// ============================================================================\n\ninterface HUDProps extends React.HTMLAttributes<HTMLDivElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerHUD({ children, className, ...props }: HUDProps) {\n  return (\n    <div\n      data-slot=\"brick-breaker-hud\"\n      className={cn(\n        'flex shrink-0 items-center justify-between p-4 text-sm',\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\n// ============================================================================\n// Overlay Components\n// ============================================================================\n\ninterface OverlayProps extends React.HTMLAttributes<HTMLDivElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerOverlay({\n  children,\n  className,\n  ...props\n}: OverlayProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  if (snapshot.state === 'playing') return null\n\n  return (\n    <div\n      data-slot=\"brick-breaker-overlay\"\n      data-state={snapshot.state}\n      className={cn(\n        'bg-background/90 pointer-events-none absolute inset-0 flex flex-col items-center justify-center',\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n}\n\nBrickBreakerOverlay.displayName = 'BrickBreakerOverlay'\n\ninterface TitleProps extends React.HTMLAttributes<HTMLHeadingElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerTitle({\n  children,\n  className,\n  ...props\n}: TitleProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  const defaultTitles: Record<GameState, string> = {\n    idle: 'BRICK BREAKER',\n    playing: '',\n    paused: 'PAUSED',\n    won: 'YOU WIN!',\n    lost: 'GAME OVER',\n    levelComplete: 'LEVEL COMPLETE!',\n  }\n\n  return (\n    <h2\n      data-slot=\"brick-breaker-title\"\n      className={cn(\n        'text-foreground text-2xl font-bold tracking-tight',\n        className\n      )}\n      {...props}\n    >\n      {children ?? defaultTitles[snapshot.state]}\n    </h2>\n  )\n}\n\ninterface MessageProps extends React.HTMLAttributes<HTMLParagraphElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerMessage({\n  children,\n  className,\n  ...props\n}: MessageProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  const defaultMessages: Partial<Record<GameState, string>> = {\n    idle: 'Click or press Space to start',\n    paused: 'Press Space to resume',\n    won: snapshot.score >= snapshot.highScore ? 'NEW HIGH SCORE!' : undefined,\n    lost: `Score: ${formatScore(snapshot.score)}`,\n    levelComplete: `Score: ${formatScore(snapshot.score)}`,\n  }\n\n  const message = children ?? defaultMessages[snapshot.state]\n  if (!message) return null\n\n  return (\n    <p\n      data-slot=\"brick-breaker-message\"\n      className={cn('text-muted-foreground mt-2', className)}\n      {...props}\n    >\n      {message}\n    </p>\n  )\n}\n\ninterface HintProps extends React.HTMLAttributes<HTMLParagraphElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerHint({ children, className, ...props }: HintProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  const defaultHints: Partial<Record<GameState, string>> = {\n    won: 'Press R to play again',\n    lost: 'Press R to try again',\n    levelComplete: 'Click to continue',\n  }\n\n  const hint = children ?? defaultHints[snapshot.state]\n  if (!hint) return null\n\n  return (\n    <p\n      data-slot=\"brick-breaker-hint\"\n      className={cn('text-muted-foreground mt-4 text-sm', className)}\n      {...props}\n    >\n      {hint}\n    </p>\n  )\n}\n\ninterface ScoreDisplayProps extends React.HTMLAttributes<HTMLDivElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerScoreDisplay({\n  children,\n  className,\n  ...props\n}: ScoreDisplayProps) {\n  const { snapshot } = useBrickBreakerUI()\n\n  if (snapshot.state === 'idle' || snapshot.state === 'playing') return null\n\n  return (\n    <div\n      data-slot=\"brick-breaker-score-display\"\n      className={cn('text-foreground mt-4 text-lg font-medium', className)}\n      {...props}\n    >\n      {children ?? `Score: ${formatScore(snapshot.score)}`}\n    </div>\n  )\n}\n\n// ============================================================================\n// Action Button\n// ============================================================================\n\ninterface ActionButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  children?: React.ReactNode\n}\n\nexport function BrickBreakerActionButton({\n  children,\n  className,\n  onClick,\n  ...props\n}: ActionButtonProps) {\n  const { snapshot, startGame, resumeGame, resetGame, nextLevel } =\n    useBrickBreakerUI()\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    onClick?.(e)\n\n    switch (snapshot.state) {\n      case 'idle':\n        startGame()\n        break\n      case 'paused':\n        resumeGame()\n        break\n      case 'won':\n      case 'lost':\n        resetGame()\n        setTimeout(startGame, 100)\n        break\n      case 'levelComplete':\n        nextLevel()\n        break\n    }\n  }\n\n  const defaultLabels: Partial<Record<GameState, string>> = {\n    idle: 'Start Game',\n    paused: 'Resume',\n    won: 'Play Again',\n    lost: 'Try Again',\n    levelComplete: 'Next Level',\n  }\n\n  if (snapshot.state === 'playing') return null\n\n  return (\n    <button\n      type=\"button\"\n      data-slot=\"brick-breaker-action\"\n      className={cn(\n        'bg-foreground text-background hover:bg-foreground/90 mt-6 rounded-md px-6 py-2 text-sm font-medium transition-colors',\n        className\n      )}\n      onClick={handleClick}\n      {...props}\n    >\n      {children ?? defaultLabels[snapshot.state]}\n    </button>\n  )\n}\n\n// ============================================================================\n// Default UI Preset\n// ============================================================================\n\nexport function BrickBreakerDefaultUI() {\n  return (\n    <>\n      <BrickBreakerHUD>\n        <BrickBreakerScore />\n        <BrickBreakerLevel />\n        <BrickBreakerHighScore />\n      </BrickBreakerHUD>\n\n      <BrickBreakerLives className=\"absolute bottom-4 left-4\" />\n\n      <BrickBreakerOverlay>\n        <BrickBreakerTitle />\n        <BrickBreakerMessage />\n        <BrickBreakerHint />\n      </BrickBreakerOverlay>\n    </>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/types.ts",
      "content": "/** Game state machine states */\nexport type GameState = 'idle' | 'playing' | 'paused' | 'won' | 'lost' | 'levelComplete'\n\n/** Brick types with different behaviors */\nexport type BrickType =\n  | 'normal'      // Standard brick, 1 hit\n  | 'strong'      // 2 hits to destroy\n  | 'metal'       // 3 hits to destroy\n  | 'indestructible' // Cannot be destroyed\n\n/** 2D Vector for positions and velocities */\nexport interface Vector2D {\n  x: number\n  y: number\n}\n\n/** Rectangle bounds for collision detection */\nexport interface Bounds {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\n/** Collision side for proper bounce direction */\nexport type CollisionSide = 'top' | 'bottom' | 'left' | 'right' | 'corner'\n\n/** Individual brick state */\nexport interface Brick {\n  id: string\n  row: number\n  col: number\n  bounds: Bounds\n  type: BrickType\n  health: number\n  maxHealth: number\n  destroyed: boolean\n  destroyedAt?: number\n  points: number\n}\n\n/** Brick definition in level data (simplified for level design) */\nexport interface BrickDefinition {\n  /** Brick type - determines health and behavior */\n  type: BrickType\n  /** Optional custom points override */\n  points?: number\n}\n\n/** Level definition */\nexport interface Level {\n  /** Level number (1-indexed for display) */\n  id: number\n  /** Level name */\n  name: string\n  /** Grid of brick definitions. Use null for empty cells. */\n  bricks: (BrickDefinition | null)[][]\n  /** Ball speed multiplier for this level */\n  speedMultiplier?: number\n  /** Background color override */\n  backgroundColor?: string\n}\n\n/** Paddle state */\nexport interface Paddle {\n  bounds: Bounds\n  targetX: number | null\n  speed: number\n}\n\n/** Ball state */\nexport interface Ball {\n  position: Vector2D\n  velocity: Vector2D\n  radius: number\n  speed: number\n  trail: Vector2D[]\n  isLaunched: boolean\n}\n\n/** Complete game state (mutable, stored in refs) */\nexport interface GameEngine {\n  state: GameState\n  level: number\n  score: number\n  lives: number\n  bricks: Brick[]\n  paddle: Paddle\n  ball: Ball\n  combo: number\n  lastHitTime: number\n}\n\n/** Immutable snapshot for React rendering */\nexport interface GameSnapshot {\n  state: GameState\n  level: number\n  levelName: string\n  score: number\n  highScore: number\n  lives: number\n  bricks: Brick[]\n  paddle: Paddle\n  ball: Ball\n  combo: number\n  totalLevels: number\n}\n\n/** Color configuration using CSS custom properties */\nexport interface BrickBreakerColors {\n  background: string\n  paddle: string\n  ball: string\n  ballTrail: string\n  text: string\n  textMuted: string\n  /** Colors by brick type */\n  bricks: {\n    normal: string\n    strong: string\n    metal: string\n    indestructible: string\n  }\n}\n\n/** Layout configuration */\nexport interface BrickBreakerLayout {\n  /** Number of brick columns */\n  cols: number\n  /** Number of brick rows */\n  rows: number\n  /** Gap between bricks in pixels */\n  brickGap: number\n  /** Top padding for score area (ratio of height) */\n  topPadding: number\n  /** Side padding (ratio of width) */\n  sidePadding: number\n  /** Brick border radius in pixels */\n  brickBorderRadius: number\n  /** Paddle border radius in pixels (0 for sharp corners) */\n  paddleBorderRadius: number | 'auto'\n  /** Ball style: 'round', 'square', or 'custom' (requires renderBall) */\n  ballStyle: 'round' | 'square' | 'custom'\n  /** Custom ball renderer (used when ballStyle is 'custom') */\n  renderBall?: (\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    radius: number,\n    color: string\n  ) => void\n}\n\n/** Size ratios relative to canvas dimensions */\nexport interface BrickBreakerSizing {\n  paddleWidth: number\n  paddleHeight: number\n  ballRadius: number\n  paddleOffset: number\n}\n\n/** Physics configuration */\nexport interface BrickBreakerPhysics {\n  /** Base ball speed (pixels per frame at 60fps) */\n  baseSpeed: number\n  /** Speed increase per level */\n  speedPerLevel: number\n  /** Maximum ball speed cap */\n  maxSpeed: number\n  /** Paddle movement speed */\n  paddleSpeed: number\n  /** Max bounce angle from paddle edges (radians) */\n  maxBounceAngle: number\n  /** Minimum Y velocity to prevent horizontal loops */\n  minYVelocity: number\n}\n\n/** Scoring configuration */\nexport interface BrickBreakerScoring {\n  /** Points by brick type */\n  pointsByType: {\n    normal: number\n    strong: number\n    metal: number\n    indestructible: number\n  }\n  /** Combo multiplier increment */\n  comboMultiplier: number\n  /** Combo timeout in ms */\n  comboTimeout: number\n  /** Max combo multiplier */\n  maxCombo: number\n  /** Points for completing a level */\n  levelBonus: number\n}\n\n/** Gameplay configuration */\nexport interface BrickBreakerGameplay {\n  /** Starting lives */\n  startingLives: number\n  /** Max lives */\n  maxLives: number\n}\n\n/** Visual effects configuration */\nexport interface BrickBreakerEffects {\n  showTrail: boolean\n  trailLength: number\n  trailOpacity: number\n  destroyAnimationDuration: number\n  /** Screen shake on brick hit */\n  screenShake: boolean\n}\n\n/** Storage configuration */\nexport interface BrickBreakerStorage {\n  persistHighScore: boolean\n  persistProgress: boolean\n  storageKey: string\n}\n\n/** Complete configuration object */\nexport interface BrickBreakerConfig {\n  colors: BrickBreakerColors\n  layout: BrickBreakerLayout\n  sizing: BrickBreakerSizing\n  physics: BrickBreakerPhysics\n  scoring: BrickBreakerScoring\n  gameplay: BrickBreakerGameplay\n  effects: BrickBreakerEffects\n  storage: BrickBreakerStorage\n}\n\n/** Props for the BrickBreaker component */\nexport interface BrickBreakerProps {\n  /** Partial config overrides */\n  config?: DeepPartial<BrickBreakerConfig>\n  /** Custom levels (overrides built-in levels) */\n  levels?: Level[]\n  /** Starting level (1-indexed) */\n  startLevel?: number\n  /** Called when game ends */\n  onGameEnd?: (result: GameEndResult) => void\n  /** Called when score updates */\n  onScoreChange?: (score: number, combo: number) => void\n  /** Called when game state changes */\n  onStateChange?: (state: GameState) => void\n  /** Called when level changes */\n  onLevelChange?: (level: number) => void\n  /** Additional container className */\n  className?: string\n  /** Auto-focus canvas on mount */\n  autoFocus?: boolean\n  /** Show focus ring when canvas is focused (default: true) */\n  showFocusRing?: boolean\n}\n\n/** Game end result */\nexport interface GameEndResult {\n  won: boolean\n  score: number\n  highScore: number\n  level: number\n  totalLevels: number\n  bricksDestroyed: number\n  totalBricks: number\n}\n\n/** Collision detection result */\nexport interface CollisionResult {\n  collided: boolean\n  side?: CollisionSide\n  normal?: Vector2D\n  penetration?: number\n  contactPoint?: Vector2D\n}\n\n/** Canvas dimensions */\nexport interface CanvasDimensions {\n  width: number\n  height: number\n  dpr: number\n}\n\n/** Deep partial utility type */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/config.ts",
      "content": "import type { BrickBreakerConfig, BrickBreakerColors } from './types'\n\n/** Theme-aware default colors using CSS variables */\nexport const DEFAULT_COLORS: BrickBreakerColors = {\n  background: 'var(--background)',\n  paddle: 'var(--foreground)',\n  ball: 'var(--foreground)',\n  ballTrail: 'var(--muted-foreground)',\n  text: 'var(--foreground)',\n  textMuted: 'var(--muted-foreground)',\n  bricks: {\n    normal: 'var(--foreground)',\n    strong: 'var(--foreground)',\n    metal: 'var(--foreground)',\n    indestructible: 'var(--muted-foreground)',\n  },\n}\n\n/** Complete default configuration */\nexport const DEFAULT_CONFIG: BrickBreakerConfig = {\n  colors: DEFAULT_COLORS,\n  layout: {\n    cols: 8,\n    rows: 5,\n    brickGap: 4,\n    topPadding: 0.14,\n    sidePadding: 0.04,\n    brickBorderRadius: 2,\n    paddleBorderRadius: 'auto', // 'auto' = height/2 for pill shape\n    ballStyle: 'round',\n  },\n  sizing: {\n    paddleWidth: 0.18,\n    paddleHeight: 0.025,\n    ballRadius: 0.012,\n    paddleOffset: 0.08,\n  },\n  physics: {\n    baseSpeed: 5,\n    speedPerLevel: 0.3,\n    maxSpeed: 12,\n    paddleSpeed: 10,\n    maxBounceAngle: Math.PI / 3, // 60 degrees\n    minYVelocity: 2,\n  },\n  scoring: {\n    pointsByType: {\n      normal: 10,\n      strong: 25,\n      metal: 50,\n      indestructible: 0,\n    },\n    comboMultiplier: 0.25,\n    comboTimeout: 2000,\n    maxCombo: 10,\n    levelBonus: 500,\n  },\n  gameplay: {\n    startingLives: 3,\n    maxLives: 5,\n  },\n  effects: {\n    showTrail: true,\n    trailLength: 6,\n    trailOpacity: 0.4,\n    destroyAnimationDuration: 100, // Quick fade out (100ms)\n    screenShake: false,\n  },\n  storage: {\n    persistHighScore: true,\n    persistProgress: false,\n    storageKey: 'brick-breaker',\n  },\n}\n\n/** Game constants */\nexport const GAME_CONSTANTS = {\n  TARGET_FPS: 60,\n  FRAME_TIME: 1000 / 60,\n  ASPECT_RATIO: 4 / 3,\n  FONT_FAMILY: 'system-ui, -apple-system, sans-serif',\n  /** Grace period after losing a life (ms) */\n  RESPAWN_DELAY: 1000,\n  /** Time before ball auto-launches (ms) */\n  AUTO_LAUNCH_DELAY: 3000,\n} as const\n\n/** Keyboard bindings */\nexport const KEY_BINDINGS = {\n  LEFT: ['ArrowLeft', 'KeyA'] as readonly string[],\n  RIGHT: ['ArrowRight', 'KeyD'] as readonly string[],\n  START: ['Space'] as readonly string[],\n  PAUSE: ['Escape', 'KeyP'] as readonly string[],\n  RESTART: ['KeyR'] as readonly string[],\n} as const\n\n/** Brick visual properties by type */\nexport const BRICK_VISUALS = {\n  normal: {\n    opacity: 1,\n    pattern: null,\n  },\n  strong: {\n    opacity: 0.85,\n    pattern: 'diagonal',\n  },\n  metal: {\n    opacity: 0.7,\n    pattern: 'cross',\n  },\n  indestructible: {\n    opacity: 0.4,\n    pattern: 'solid',\n  },\n} as const\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/levels.ts",
      "content": "import type { Level, BrickDefinition } from './types'\n\n/** Shorthand brick definitions for level design */\nconst N: BrickDefinition = { type: 'normal' }\nconst S: BrickDefinition = { type: 'strong' }\nconst M: BrickDefinition = { type: 'metal' }\nconst X: BrickDefinition = { type: 'indestructible' }\nconst _: null = null // Empty space\n\n/**\n * Built-in levels for the brick breaker game.\n * Each level is a 2D array where:\n * - N = normal brick (1 hit)\n * - S = strong brick (2 hits)\n * - M = metal brick (3 hits)\n * - X = indestructible brick\n * - _ = empty space\n */\nexport const DEFAULT_LEVELS: Level[] = [\n  // Level 1: Introduction - Simple rows\n  {\n    id: 1,\n    name: 'First Steps',\n    speedMultiplier: 1.0,\n    bricks: [\n      [N, N, N, N, N, N, N, N],\n      [N, N, N, N, N, N, N, N],\n      [N, N, N, N, N, N, N, N],\n      [_, _, _, _, _, _, _, _],\n      [_, _, _, _, _, _, _, _],\n    ],\n  },\n\n  // Level 2: Checkerboard\n  {\n    id: 2,\n    name: 'Checkerboard',\n    speedMultiplier: 1.0,\n    bricks: [\n      [N, _, N, _, N, _, N, _],\n      [_, N, _, N, _, N, _, N],\n      [N, _, N, _, N, _, N, _],\n      [_, N, _, N, _, N, _, N],\n      [N, _, N, _, N, _, N, _],\n    ],\n  },\n\n  // Level 3: Pyramid\n  {\n    id: 3,\n    name: 'Pyramid',\n    speedMultiplier: 1.05,\n    bricks: [\n      [_, _, _, N, N, _, _, _],\n      [_, _, N, N, N, N, _, _],\n      [_, N, N, N, N, N, N, _],\n      [N, N, N, N, N, N, N, N],\n      [_, _, _, _, _, _, _, _],\n    ],\n  },\n\n  // Level 4: Introducing Strong Bricks\n  {\n    id: 4,\n    name: 'Getting Stronger',\n    speedMultiplier: 1.05,\n    bricks: [\n      [N, N, N, N, N, N, N, N],\n      [N, S, S, S, S, S, S, N],\n      [N, S, N, N, N, N, S, N],\n      [N, S, S, S, S, S, S, N],\n      [N, N, N, N, N, N, N, N],\n    ],\n  },\n\n  // Level 5: Diamond\n  {\n    id: 5,\n    name: 'Diamond',\n    speedMultiplier: 1.1,\n    bricks: [\n      [_, _, _, S, S, _, _, _],\n      [_, _, S, N, N, S, _, _],\n      [_, S, N, N, N, N, S, _],\n      [_, _, S, N, N, S, _, _],\n      [_, _, _, S, S, _, _, _],\n    ],\n  },\n\n  // Level 6: Walls\n  {\n    id: 6,\n    name: 'The Walls',\n    speedMultiplier: 1.1,\n    bricks: [\n      [S, _, N, N, N, N, _, S],\n      [S, _, N, N, N, N, _, S],\n      [S, _, N, N, N, N, _, S],\n      [S, _, N, N, N, N, _, S],\n      [S, _, N, N, N, N, _, S],\n    ],\n  },\n\n  // Level 7: Introducing Metal\n  {\n    id: 7,\n    name: 'Metal Core',\n    speedMultiplier: 1.15,\n    bricks: [\n      [N, N, N, N, N, N, N, N],\n      [N, S, S, S, S, S, S, N],\n      [N, S, M, M, M, M, S, N],\n      [N, S, S, S, S, S, S, N],\n      [N, N, N, N, N, N, N, N],\n    ],\n  },\n\n  // Level 8: Stripes\n  {\n    id: 8,\n    name: 'Stripes',\n    speedMultiplier: 1.15,\n    bricks: [\n      [M, S, N, S, M, S, N, S],\n      [S, N, S, M, S, N, S, M],\n      [N, S, M, S, N, S, M, S],\n      [S, M, S, N, S, M, S, N],\n      [M, S, N, S, M, S, N, S],\n    ],\n  },\n\n  // Level 9: Fortress with Indestructible\n  {\n    id: 9,\n    name: 'Fortress',\n    speedMultiplier: 1.2,\n    bricks: [\n      [X, N, N, N, N, N, N, X],\n      [N, S, S, S, S, S, S, N],\n      [N, S, M, M, M, M, S, N],\n      [N, S, S, S, S, S, S, N],\n      [X, N, N, N, N, N, N, X],\n    ],\n  },\n\n  // Level 10: Final Challenge\n  {\n    id: 10,\n    name: 'The Gauntlet',\n    speedMultiplier: 1.25,\n    bricks: [\n      [X, M, S, N, N, S, M, X],\n      [M, S, N, N, N, N, S, M],\n      [S, N, N, M, M, N, N, S],\n      [M, S, N, N, N, N, S, M],\n      [X, M, S, N, N, S, M, X],\n    ],\n  },\n]\n\n/**\n * Create a custom level from a pattern string.\n * Use this for quick level prototyping.\n *\n * @example\n * ```ts\n * const level = createLevelFromPattern(1, 'My Level', `\n *   N N N N N N N N\n *   . S S S S S S .\n *   . S M M M M S .\n *   . S S S S S S .\n *   N N N N N N N N\n * `)\n * ```\n */\nexport function createLevelFromPattern(\n  id: number,\n  name: string,\n  pattern: string,\n  speedMultiplier: number = 1.0\n): Level {\n  const lines = pattern\n    .trim()\n    .split('\\n')\n    .map((line) => line.trim())\n    .filter((line) => line.length > 0)\n\n  const bricks: (BrickDefinition | null)[][] = lines.map((line) => {\n    const cells = line.split(/\\s+/)\n    return cells.map((cell) => {\n      switch (cell.toUpperCase()) {\n        case 'N':\n          return { type: 'normal' as const }\n        case 'S':\n          return { type: 'strong' as const }\n        case 'M':\n          return { type: 'metal' as const }\n        case 'X':\n          return { type: 'indestructible' as const }\n        case '.':\n        case '_':\n        case '0':\n          return null\n        default:\n          return null\n      }\n    })\n  })\n\n  return { id, name, bricks, speedMultiplier }\n}\n\n/**\n * Generate a random level with given parameters.\n */\nexport function generateRandomLevel(\n  id: number,\n  cols: number = 8,\n  rows: number = 5,\n  difficulty: number = 0.5\n): Level {\n  const bricks: (BrickDefinition | null)[][] = []\n\n  for (let row = 0; row < rows; row++) {\n    const rowBricks: (BrickDefinition | null)[] = []\n    for (let col = 0; col < cols; col++) {\n      // Higher rows have stronger bricks\n      const rowDifficulty = (rows - row) / rows\n      const rand = Math.random()\n\n      if (rand < 0.1) {\n        // 10% empty\n        rowBricks.push(null)\n      } else if (rand < 0.1 + 0.5 * (1 - difficulty * rowDifficulty)) {\n        // Normal bricks\n        rowBricks.push({ type: 'normal' })\n      } else if (rand < 0.8) {\n        // Strong bricks\n        rowBricks.push({ type: 'strong' })\n      } else if (rand < 0.95) {\n        // Metal bricks\n        rowBricks.push({ type: 'metal' })\n      } else {\n        // Rare indestructible\n        rowBricks.push({ type: 'indestructible' })\n      }\n    }\n    bricks.push(rowBricks)\n  }\n\n  return {\n    id,\n    name: `Random Level ${id}`,\n    bricks,\n    speedMultiplier: 1 + difficulty * 0.3,\n  }\n}\n\n/**\n * Get brick health by type\n */\nexport function getBrickHealth(type: BrickDefinition['type']): number {\n  switch (type) {\n    case 'normal':\n      return 1\n    case 'strong':\n      return 2\n    case 'metal':\n      return 3\n    case 'indestructible':\n      return Infinity\n  }\n}\n\n/**\n * Check if a level is completable (has at least one destructible brick)\n */\nexport function isLevelCompletable(level: Level): boolean {\n  return level.bricks.some((row) =>\n    row.some((brick) => brick !== null && brick.type !== 'indestructible')\n  )\n}\n\n/**\n * Count total destructible bricks in a level\n */\nexport function countDestructibleBricks(level: Level): number {\n  let count = 0\n  for (const row of level.bricks) {\n    for (const brick of row) {\n      if (brick !== null && brick.type !== 'indestructible') {\n        count++\n      }\n    }\n  }\n  return count\n}\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/utils.ts",
      "content": "import type {\n  Vector2D,\n  Bounds,\n  CollisionResult,\n  CollisionSide,\n  BrickBreakerConfig,\n  DeepPartial,\n  Ball,\n  Brick,\n  Paddle,\n} from './types'\n\n// ============================================================================\n// Configuration Utilities\n// ============================================================================\n\n/**\n * Deep merge configuration objects\n */\nexport function mergeConfig(\n  base: BrickBreakerConfig,\n  overrides?: DeepPartial<BrickBreakerConfig>\n): BrickBreakerConfig {\n  if (!overrides) return base\n\n  return {\n    colors: {\n      ...base.colors,\n      ...overrides.colors,\n      bricks: { ...base.colors.bricks, ...overrides.colors?.bricks },\n    },\n    layout: { ...base.layout, ...overrides.layout },\n    sizing: { ...base.sizing, ...overrides.sizing },\n    physics: { ...base.physics, ...overrides.physics },\n    scoring: {\n      ...base.scoring,\n      ...overrides.scoring,\n      pointsByType: {\n        ...base.scoring.pointsByType,\n        ...overrides.scoring?.pointsByType,\n      },\n    },\n    gameplay: { ...base.gameplay, ...overrides.gameplay },\n    effects: { ...base.effects, ...overrides.effects },\n    storage: { ...base.storage, ...overrides.storage },\n  }\n}\n\n// ============================================================================\n// Vector Math\n// ============================================================================\n\n/** Normalize vector to unit length */\nexport function normalize(v: Vector2D): Vector2D {\n  const len = Math.sqrt(v.x * v.x + v.y * v.y)\n  if (len === 0) return { x: 0, y: -1 }\n  return { x: v.x / len, y: v.y / len }\n}\n\n/** Calculate vector magnitude */\nexport function magnitude(v: Vector2D): number {\n  return Math.sqrt(v.x * v.x + v.y * v.y)\n}\n\n/** Scale vector by scalar */\nexport function scale(v: Vector2D, s: number): Vector2D {\n  return { x: v.x * s, y: v.y * s }\n}\n\n/** Add two vectors */\nexport function add(a: Vector2D, b: Vector2D): Vector2D {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n\n/** Subtract vectors (a - b) */\nexport function subtract(a: Vector2D, b: Vector2D): Vector2D {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\n/** Dot product of two vectors */\nexport function dot(a: Vector2D, b: Vector2D): number {\n  return a.x * b.x + a.y * b.y\n}\n\n/** Reflect velocity off a surface normal */\nexport function reflect(velocity: Vector2D, normal: Vector2D): Vector2D {\n  const d = dot(velocity, normal)\n  return {\n    x: velocity.x - 2 * d * normal.x,\n    y: velocity.y - 2 * d * normal.y,\n  }\n}\n\n/** Clamp value between min and max */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value))\n}\n\n/** Linear interpolation */\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t\n}\n\n// ============================================================================\n// Collision Detection - AABB vs Circle with Proper Side Detection\n// ============================================================================\n\n/**\n * Detect collision between a circle (ball) and axis-aligned rectangle (brick/paddle).\n * Returns collision info including which side was hit for proper bounce direction.\n */\nexport function detectCollision(\n  ballPos: Vector2D,\n  ballRadius: number,\n  ballVel: Vector2D,\n  rect: Bounds\n): CollisionResult {\n  // Find the closest point on the rectangle to the ball center\n  const closestX = clamp(ballPos.x, rect.x, rect.x + rect.width)\n  const closestY = clamp(ballPos.y, rect.y, rect.y + rect.height)\n\n  // Calculate distance from ball center to closest point\n  const dx = ballPos.x - closestX\n  const dy = ballPos.y - closestY\n  const distSq = dx * dx + dy * dy\n  const radiusSq = ballRadius * ballRadius\n\n  // No collision if distance > radius\n  if (distSq > radiusSq) {\n    return { collided: false }\n  }\n\n  const dist = Math.sqrt(distSq)\n  const penetration = ballRadius - dist\n\n  // Determine collision side based on approach direction and position\n  let side: CollisionSide\n  let normal: Vector2D\n\n  if (dist < 0.001) {\n    // Ball center is inside rect - use velocity to determine exit direction\n    const rectCenterX = rect.x + rect.width / 2\n    const rectCenterY = rect.y + rect.height / 2\n    const toBallX = ballPos.x - rectCenterX\n    const toBallY = ballPos.y - rectCenterY\n\n    // Determine which edge is closest\n    const halfW = rect.width / 2\n    const halfH = rect.height / 2\n    const overlapX = halfW - Math.abs(toBallX)\n    const overlapY = halfH - Math.abs(toBallY)\n\n    if (overlapX < overlapY) {\n      // Exit through left or right\n      if (toBallX > 0) {\n        side = 'right'\n        normal = { x: 1, y: 0 }\n      } else {\n        side = 'left'\n        normal = { x: -1, y: 0 }\n      }\n    } else {\n      // Exit through top or bottom\n      if (toBallY > 0) {\n        side = 'bottom'\n        normal = { x: 0, y: 1 }\n      } else {\n        side = 'top'\n        normal = { x: 0, y: -1 }\n      }\n    }\n  } else {\n    // Normal case - calculate normal from closest point\n    normal = { x: dx / dist, y: dy / dist }\n\n    // Determine side based on where closest point is\n    const isOnLeft = closestX <= rect.x + 0.01\n    const isOnRight = closestX >= rect.x + rect.width - 0.01\n    const isOnTop = closestY <= rect.y + 0.01\n    const isOnBottom = closestY >= rect.y + rect.height - 0.01\n\n    if (isOnTop && !isOnLeft && !isOnRight) {\n      side = 'top'\n      normal = { x: 0, y: -1 }\n    } else if (isOnBottom && !isOnLeft && !isOnRight) {\n      side = 'bottom'\n      normal = { x: 0, y: 1 }\n    } else if (isOnLeft && !isOnTop && !isOnBottom) {\n      side = 'left'\n      normal = { x: -1, y: 0 }\n    } else if (isOnRight && !isOnTop && !isOnBottom) {\n      side = 'right'\n      normal = { x: 1, y: 0 }\n    } else {\n      // Corner collision\n      side = 'corner'\n      // Keep the calculated normal for corners\n    }\n  }\n\n  return {\n    collided: true,\n    side,\n    normal,\n    penetration,\n    contactPoint: { x: closestX, y: closestY },\n  }\n}\n\n/**\n * Resolve ball collision - move ball out of collision and reflect velocity.\n * Returns the new ball state.\n */\nexport function resolveBallBrickCollision(\n  ball: Ball,\n  brick: Brick,\n  collision: CollisionResult,\n  config: BrickBreakerConfig\n): Ball {\n  if (!collision.collided || !collision.normal || collision.penetration === undefined) {\n    return ball\n  }\n\n  // Move ball out of collision\n  const newPos = {\n    x: ball.position.x + collision.normal.x * (collision.penetration + 0.5),\n    y: ball.position.y + collision.normal.y * (collision.penetration + 0.5),\n  }\n\n  // Reflect velocity\n  let newVel = reflect(ball.velocity, collision.normal)\n\n  // Ensure minimum Y velocity to prevent horizontal loops\n  if (Math.abs(newVel.y) < config.physics.minYVelocity) {\n    newVel.y = newVel.y >= 0 ? config.physics.minYVelocity : -config.physics.minYVelocity\n    // Renormalize to maintain speed\n    const speed = ball.speed\n    newVel = scale(normalize(newVel), speed)\n  }\n\n  return {\n    ...ball,\n    position: newPos,\n    velocity: newVel,\n  }\n}\n\n/**\n * Handle ball-paddle collision with angle adjustment based on hit position.\n */\nexport function resolveBallPaddleCollision(\n  ball: Ball,\n  paddle: Paddle,\n  collision: CollisionResult,\n  config: BrickBreakerConfig\n): Ball {\n  if (!collision.collided || !collision.normal || collision.penetration === undefined) {\n    return ball\n  }\n\n  // Only bounce if ball is moving downward\n  if (ball.velocity.y <= 0) {\n    return ball\n  }\n\n  // Calculate hit position relative to paddle center (-1 to 1)\n  const paddleCenterX = paddle.bounds.x + paddle.bounds.width / 2\n  const hitPos = (ball.position.x - paddleCenterX) / (paddle.bounds.width / 2)\n  const clampedHitPos = clamp(hitPos, -1, 1)\n\n  // Calculate bounce angle based on hit position\n  // Center = straight up, edges = angled\n  const bounceAngle = clampedHitPos * config.physics.maxBounceAngle\n\n  // Create new velocity from angle\n  const speed = ball.speed\n  const newVel: Vector2D = {\n    x: Math.sin(bounceAngle) * speed,\n    y: -Math.cos(bounceAngle) * speed,\n  }\n\n  // Move ball above paddle\n  const newY = paddle.bounds.y - ball.radius - 1\n\n  return {\n    ...ball,\n    position: { x: ball.position.x, y: newY },\n    velocity: newVel,\n  }\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/** Generate unique ID */\nexport function generateId(): string {\n  return Math.random().toString(36).substring(2, 9)\n}\n\n/** Resolve CSS variable to actual color value */\nexport function resolveCssColor(color: string, element: HTMLElement): string {\n  if (!color.includes('var(')) return color\n\n  const computed = getComputedStyle(element)\n  const varMatch = color.match(/var\\((--[^)]+)\\)/)\n\n  if (varMatch) {\n    const varName = varMatch[1]\n    const resolved = computed.getPropertyValue(varName).trim()\n    return resolved || color\n  }\n\n  return color\n}\n\n/** Format score with thousands separator */\nexport function formatScore(score: number): string {\n  return score.toLocaleString()\n}\n\n/** Storage utilities */\nexport const storage = {\n  get(key: string, defaultValue: number = 0): number {\n    if (typeof window === 'undefined') return defaultValue\n    try {\n      const value = localStorage.getItem(key)\n      return value ? parseInt(value, 10) : defaultValue\n    } catch {\n      return defaultValue\n    }\n  },\n\n  set(key: string, value: number): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.setItem(key, value.toString())\n    } catch {\n      // Silently fail\n    }\n  },\n\n  getJSON<T>(key: string, defaultValue: T): T {\n    if (typeof window === 'undefined') return defaultValue\n    try {\n      const value = localStorage.getItem(key)\n      return value ? JSON.parse(value) : defaultValue\n    } catch {\n      return defaultValue\n    }\n  },\n\n  setJSON<T>(key: string, value: T): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.setItem(key, JSON.stringify(value))\n    } catch {\n      // Silently fail\n    }\n  },\n}\n\n/** Degrees to radians */\nexport function degToRad(degrees: number): number {\n  return (degrees * Math.PI) / 180\n}\n\n/** Create velocity vector from angle and speed */\nexport function velocityFromAngle(angle: number, speed: number): Vector2D {\n  return {\n    x: Math.cos(angle) * speed,\n    y: Math.sin(angle) * speed,\n  }\n}\n\n/**\n * Check if ball is moving toward a rectangle (for early collision skip)\n */\nexport function isBallMovingToward(ball: Ball, rect: Bounds): boolean {\n  const rectCenterX = rect.x + rect.width / 2\n  const rectCenterY = rect.y + rect.height / 2\n\n  const toRect = {\n    x: rectCenterX - ball.position.x,\n    y: rectCenterY - ball.position.y,\n  }\n\n  return dot(ball.velocity, toRect) > 0\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/brick-breaker/use-brick-breaker.ts",
      "content": "'use client'\n\nimport * as React from 'react'\nimport type {\n  GameState,\n  GameSnapshot,\n  GameEndResult,\n  BrickBreakerConfig,\n  Brick,\n  Ball,\n  Paddle,\n  Level,\n  CanvasDimensions,\n  BrickType,\n} from './types'\nimport { DEFAULT_CONFIG, GAME_CONSTANTS } from './config'\nimport { DEFAULT_LEVELS, getBrickHealth } from './levels'\nimport {\n  detectCollision,\n  resolveBallBrickCollision,\n  resolveBallPaddleCollision,\n  generateId,\n  clamp,\n  normalize,\n  scale,\n  magnitude,\n  storage,\n} from './utils'\n\ninterface UseBrickBreakerOptions {\n  config: BrickBreakerConfig\n  levels: Level[]\n  startLevel: number\n  canvasDimensions: CanvasDimensions\n  onGameEnd?: (result: GameEndResult) => void\n  onScoreChange?: (score: number, combo: number) => void\n  onStateChange?: (state: GameState) => void\n  onLevelChange?: (level: number) => void\n}\n\ninterface UseBrickBreakerReturn {\n  snapshot: GameSnapshot\n  startGame: () => void\n  pauseGame: () => void\n  resumeGame: () => void\n  resetGame: () => void\n  nextLevel: () => void\n  movePaddle: (direction: 'left' | 'right' | 'none') => void\n  setPaddlePosition: (x: number) => void\n  launchBall: () => void\n}\n\n/**\n * Create bricks from level definition\n */\nfunction createBricksFromLevel(\n  level: Level,\n  config: BrickBreakerConfig,\n  dimensions: CanvasDimensions\n): Brick[] {\n  const { brickGap, topPadding, sidePadding } = config.layout\n  const { width, height } = dimensions\n\n  const rows = level.bricks.length\n  const cols = level.bricks[0]?.length || config.layout.cols\n\n  const playAreaX = width * sidePadding\n  const playAreaY = height * topPadding\n  const playAreaWidth = width * (1 - 2 * sidePadding)\n  const playAreaHeight = height * 0.35\n\n  const brickWidth = (playAreaWidth - (cols - 1) * brickGap) / cols\n  const brickHeight = (playAreaHeight - (rows - 1) * brickGap) / rows\n\n  const bricks: Brick[] = []\n\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      const def = level.bricks[row]?.[col]\n      if (!def) continue\n\n      const health = getBrickHealth(def.type)\n      const points = def.points ?? config.scoring.pointsByType[def.type]\n\n      bricks.push({\n        id: generateId(),\n        row,\n        col,\n        bounds: {\n          x: playAreaX + col * (brickWidth + brickGap),\n          y: playAreaY + row * (brickHeight + brickGap),\n          width: brickWidth,\n          height: brickHeight,\n        },\n        type: def.type,\n        health,\n        maxHealth: health,\n        destroyed: false,\n        points,\n      })\n    }\n  }\n\n  return bricks\n}\n\n/**\n * Create paddle\n */\nfunction createPaddle(\n  config: BrickBreakerConfig,\n  dimensions: CanvasDimensions\n): Paddle {\n  const { paddleWidth, paddleHeight, paddleOffset } = config.sizing\n  const { width, height } = dimensions\n\n  const w = width * paddleWidth\n  const h = height * paddleHeight\n\n  return {\n    bounds: {\n      x: (width - w) / 2,\n      y: height * (1 - paddleOffset) - h,\n      width: w,\n      height: h,\n    },\n    targetX: null,\n    speed: config.physics.paddleSpeed,\n  }\n}\n\n/**\n * Create ball attached to paddle\n */\nfunction createBall(\n  config: BrickBreakerConfig,\n  dimensions: CanvasDimensions,\n  paddle: Paddle,\n  levelIndex: number\n): Ball {\n  const { ballRadius } = config.sizing\n  const { width } = dimensions\n  const { baseSpeed, speedPerLevel, maxSpeed } = config.physics\n\n  const radius = width * ballRadius\n  const speed = Math.min(baseSpeed + levelIndex * speedPerLevel, maxSpeed)\n\n  return {\n    position: {\n      x: paddle.bounds.x + paddle.bounds.width / 2,\n      y: paddle.bounds.y - radius - 2,\n    },\n    velocity: { x: 0, y: 0 },\n    radius,\n    speed,\n    trail: [],\n    isLaunched: false,\n  }\n}\n\n/**\n * Launch ball from paddle with random angle\n */\nfunction launchBallFromPaddle(ball: Ball): Ball {\n  // Random angle between -45 and -135 degrees (upward arc)\n  const angle = -Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 2)\n\n  return {\n    ...ball,\n    velocity: {\n      x: Math.cos(angle) * ball.speed,\n      y: Math.sin(angle) * ball.speed,\n    },\n    isLaunched: true,\n  }\n}\n\n/**\n * Main game hook with proper refs-based physics engine\n */\nexport function useBrickBreaker(\n  options: UseBrickBreakerOptions\n): UseBrickBreakerReturn {\n  const {\n    config,\n    levels,\n    startLevel,\n    canvasDimensions,\n    onGameEnd,\n    onScoreChange,\n    onStateChange,\n    onLevelChange,\n  } = options\n\n  // React state for rendering (updated each frame)\n  const [, forceRender] = React.useReducer((x) => x + 1, 0)\n\n  // Game state stored in refs for mutation during game loop\n  const gameStateRef = React.useRef<GameState>('idle')\n  const levelIndexRef = React.useRef(startLevel - 1)\n  const scoreRef = React.useRef(0)\n  const highScoreRef = React.useRef(0)\n  const livesRef = React.useRef(config.gameplay.startingLives)\n  const comboRef = React.useRef(0)\n  const lastHitTimeRef = React.useRef(0)\n\n  const bricksRef = React.useRef<Brick[]>([])\n  const paddleRef = React.useRef<Paddle>(createPaddle(config, canvasDimensions))\n  const ballRef = React.useRef<Ball>(\n    createBall(config, canvasDimensions, paddleRef.current, levelIndexRef.current)\n  )\n\n  const animationFrameRef = React.useRef<number>(0)\n  const lastFrameTimeRef = React.useRef<number>(0)\n  const paddleDirectionRef = React.useRef<'left' | 'right' | 'none'>('none')\n  const totalBricksRef = React.useRef(0)\n  const destroyedBricksRef = React.useRef(0)\n\n  // Load high score\n  React.useEffect(() => {\n    if (config.storage.persistHighScore) {\n      highScoreRef.current = storage.get(`${config.storage.storageKey}-highscore`, 0)\n    }\n  }, [config.storage])\n\n  // Initialize level\n  const initLevel = React.useCallback(\n    (levelIndex: number) => {\n      const level = levels[levelIndex] || levels[0]\n      if (!level) return\n\n      const newBricks = createBricksFromLevel(level, config, canvasDimensions)\n      const newPaddle = createPaddle(config, canvasDimensions)\n      const newBall = createBall(config, canvasDimensions, newPaddle, levelIndex)\n\n      // Apply level speed multiplier\n      if (level.speedMultiplier) {\n        newBall.speed *= level.speedMultiplier\n      }\n\n      bricksRef.current = newBricks\n      paddleRef.current = newPaddle\n      ballRef.current = newBall\n      comboRef.current = 0\n\n      totalBricksRef.current = newBricks.filter(\n        (b) => b.type !== 'indestructible'\n      ).length\n      destroyedBricksRef.current = 0\n\n      forceRender()\n    },\n    [config, canvasDimensions, levels]\n  )\n\n  // Initialize on mount\n  React.useEffect(() => {\n    initLevel(levelIndexRef.current)\n  }, [initLevel])\n\n  // Reinitialize on dimension change\n  React.useEffect(() => {\n    if (gameStateRef.current === 'idle') {\n      initLevel(levelIndexRef.current)\n    }\n  }, [canvasDimensions, initLevel])\n\n  // Game loop\n  const gameLoop = React.useCallback(\n    (timestamp: number) => {\n      if (gameStateRef.current !== 'playing') return\n\n      const deltaTime = timestamp - lastFrameTimeRef.current\n      lastFrameTimeRef.current = timestamp\n\n      // Cap delta time to prevent physics issues\n      const dt = Math.min(deltaTime, 50) / GAME_CONSTANTS.FRAME_TIME\n\n      const paddle = paddleRef.current\n      const ball = ballRef.current\n      const bricks = bricksRef.current\n\n      // ========== UPDATE PADDLE ==========\n      let newPaddleX = paddle.bounds.x\n\n      // Keyboard control\n      if (paddleDirectionRef.current === 'left') {\n        newPaddleX -= paddle.speed * dt\n      } else if (paddleDirectionRef.current === 'right') {\n        newPaddleX += paddle.speed * dt\n      }\n\n      // Mouse/touch control (smooth follow)\n      if (paddle.targetX !== null) {\n        const targetX = paddle.targetX - paddle.bounds.width / 2\n        const diff = targetX - newPaddleX\n        newPaddleX += diff * 0.2 * dt\n      }\n\n      // Clamp to bounds\n      newPaddleX = clamp(newPaddleX, 0, canvasDimensions.width - paddle.bounds.width)\n      paddle.bounds.x = newPaddleX\n\n      // ========== UPDATE BALL ==========\n      if (!ball.isLaunched) {\n        // Ball follows paddle\n        ball.position.x = paddle.bounds.x + paddle.bounds.width / 2\n        ball.position.y = paddle.bounds.y - ball.radius - 2\n      } else {\n        // Update trail\n        if (config.effects.showTrail) {\n          ball.trail.push({ ...ball.position })\n          if (ball.trail.length > config.effects.trailLength) {\n            ball.trail.shift()\n          }\n        }\n\n        // Move ball\n        let newX = ball.position.x + ball.velocity.x * dt\n        let newY = ball.position.y + ball.velocity.y * dt\n        let newVelX = ball.velocity.x\n        let newVelY = ball.velocity.y\n\n        // Wall collisions\n        if (newX - ball.radius < 0) {\n          newX = ball.radius\n          newVelX = Math.abs(newVelX)\n        } else if (newX + ball.radius > canvasDimensions.width) {\n          newX = canvasDimensions.width - ball.radius\n          newVelX = -Math.abs(newVelX)\n        }\n\n        if (newY - ball.radius < 0) {\n          newY = ball.radius\n          newVelY = Math.abs(newVelY)\n        }\n\n        ball.position.x = newX\n        ball.position.y = newY\n        ball.velocity.x = newVelX\n        ball.velocity.y = newVelY\n\n        // Check if ball fell below screen\n        if (newY - ball.radius > canvasDimensions.height) {\n          livesRef.current--\n\n          if (livesRef.current <= 0) {\n            // Game over\n            gameStateRef.current = 'lost'\n            onStateChange?.('lost')\n            onGameEnd?.({\n              won: false,\n              score: scoreRef.current,\n              highScore: Math.max(scoreRef.current, highScoreRef.current),\n              level: levelIndexRef.current + 1,\n              totalLevels: levels.length,\n              bricksDestroyed: destroyedBricksRef.current,\n              totalBricks: totalBricksRef.current,\n            })\n          } else {\n            // Reset ball\n            const newBall = createBall(\n              config,\n              canvasDimensions,\n              paddle,\n              levelIndexRef.current\n            )\n            if (levels[levelIndexRef.current]?.speedMultiplier) {\n              newBall.speed *= levels[levelIndexRef.current].speedMultiplier!\n            }\n            ballRef.current = newBall\n            comboRef.current = 0\n          }\n\n          forceRender()\n          animationFrameRef.current = requestAnimationFrame(gameLoop)\n          return\n        }\n\n        // ========== PADDLE COLLISION ==========\n        const paddleCollision = detectCollision(\n          ball.position,\n          ball.radius,\n          ball.velocity,\n          paddle.bounds\n        )\n\n        if (paddleCollision.collided && ball.velocity.y > 0) {\n          const resolved = resolveBallPaddleCollision(\n            ball,\n            paddle,\n            paddleCollision,\n            config\n          )\n          ball.position = resolved.position\n          ball.velocity = resolved.velocity\n          comboRef.current = 0 // Reset combo on paddle hit\n        }\n\n        // ========== BRICK COLLISIONS ==========\n        let hitBrick = false\n\n        for (const brick of bricks) {\n          if (brick.destroyed || hitBrick) continue\n\n          const collision = detectCollision(\n            ball.position,\n            ball.radius,\n            ball.velocity,\n            brick.bounds\n          )\n\n          if (collision.collided) {\n            hitBrick = true\n\n            // Resolve collision\n            const resolved = resolveBallBrickCollision(ball, brick, collision, config)\n            ball.position = resolved.position\n            ball.velocity = resolved.velocity\n\n            // Damage brick\n            if (brick.type !== 'indestructible') {\n              brick.health--\n\n              if (brick.health <= 0) {\n                brick.destroyed = true\n                brick.destroyedAt = Date.now()\n                destroyedBricksRef.current++\n\n                // Update combo\n                const now = Date.now()\n                if (now - lastHitTimeRef.current < config.scoring.comboTimeout) {\n                  comboRef.current = Math.min(\n                    comboRef.current + 1,\n                    config.scoring.maxCombo\n                  )\n                } else {\n                  comboRef.current = 1\n                }\n                lastHitTimeRef.current = now\n\n                // Calculate score with combo\n                const multiplier = 1 + comboRef.current * config.scoring.comboMultiplier\n                const points = Math.floor(brick.points * multiplier)\n                scoreRef.current += points\n\n                // Update high score\n                if (scoreRef.current > highScoreRef.current) {\n                  highScoreRef.current = scoreRef.current\n                  if (config.storage.persistHighScore) {\n                    storage.set(\n                      `${config.storage.storageKey}-highscore`,\n                      highScoreRef.current\n                    )\n                  }\n                }\n\n                onScoreChange?.(scoreRef.current, comboRef.current)\n              }\n            }\n\n            break // Only handle one collision per frame\n          }\n        }\n\n        // ========== CHECK WIN CONDITION ==========\n        const remainingBricks = bricks.filter(\n          (b) => !b.destroyed && b.type !== 'indestructible'\n        )\n\n        if (remainingBricks.length === 0) {\n          // Level complete!\n          scoreRef.current += config.scoring.levelBonus\n          onScoreChange?.(scoreRef.current, comboRef.current)\n\n          if (levelIndexRef.current >= levels.length - 1) {\n            // Game won!\n            gameStateRef.current = 'won'\n            onStateChange?.('won')\n            onGameEnd?.({\n              won: true,\n              score: scoreRef.current,\n              highScore: Math.max(scoreRef.current, highScoreRef.current),\n              level: levelIndexRef.current + 1,\n              totalLevels: levels.length,\n              bricksDestroyed: destroyedBricksRef.current,\n              totalBricks: totalBricksRef.current,\n            })\n          } else {\n            // Next level\n            gameStateRef.current = 'levelComplete'\n            onStateChange?.('levelComplete')\n          }\n\n          forceRender()\n          return\n        }\n      }\n\n      forceRender()\n      animationFrameRef.current = requestAnimationFrame(gameLoop)\n    },\n    [config, canvasDimensions, levels, onGameEnd, onScoreChange, onStateChange]\n  )\n\n  // Start/stop loop based on state\n  React.useEffect(() => {\n    if (gameStateRef.current === 'playing') {\n      lastFrameTimeRef.current = performance.now()\n      animationFrameRef.current = requestAnimationFrame(gameLoop)\n    }\n\n    return () => {\n      cancelAnimationFrame(animationFrameRef.current)\n    }\n  }, [gameLoop])\n\n  // ========== PUBLIC ACTIONS ==========\n\n  const startGame = React.useCallback(() => {\n    if (gameStateRef.current === 'idle' || gameStateRef.current === 'lost') {\n      levelIndexRef.current = startLevel - 1\n      scoreRef.current = 0\n      livesRef.current = config.gameplay.startingLives\n      destroyedBricksRef.current = 0\n      initLevel(levelIndexRef.current)\n    }\n\n    if (!ballRef.current.isLaunched) {\n      ballRef.current = launchBallFromPaddle(ballRef.current)\n    }\n\n    gameStateRef.current = 'playing'\n    onStateChange?.('playing')\n    lastFrameTimeRef.current = performance.now()\n    animationFrameRef.current = requestAnimationFrame(gameLoop)\n    forceRender()\n  }, [config.gameplay.startingLives, startLevel, initLevel, onStateChange, gameLoop])\n\n  const pauseGame = React.useCallback(() => {\n    if (gameStateRef.current === 'playing') {\n      gameStateRef.current = 'paused'\n      onStateChange?.('paused')\n      cancelAnimationFrame(animationFrameRef.current)\n      forceRender()\n    }\n  }, [onStateChange])\n\n  const resumeGame = React.useCallback(() => {\n    if (gameStateRef.current === 'paused') {\n      gameStateRef.current = 'playing'\n      onStateChange?.('playing')\n      lastFrameTimeRef.current = performance.now()\n      animationFrameRef.current = requestAnimationFrame(gameLoop)\n      forceRender()\n    }\n  }, [onStateChange, gameLoop])\n\n  const resetGame = React.useCallback(() => {\n    cancelAnimationFrame(animationFrameRef.current)\n    levelIndexRef.current = startLevel - 1\n    scoreRef.current = 0\n    livesRef.current = config.gameplay.startingLives\n    destroyedBricksRef.current = 0\n    gameStateRef.current = 'idle'\n    initLevel(levelIndexRef.current)\n    onStateChange?.('idle')\n    forceRender()\n  }, [config.gameplay.startingLives, startLevel, initLevel, onStateChange])\n\n  const nextLevel = React.useCallback(() => {\n    if (\n      gameStateRef.current === 'levelComplete' &&\n      levelIndexRef.current < levels.length - 1\n    ) {\n      levelIndexRef.current++\n      initLevel(levelIndexRef.current)\n      onLevelChange?.(levelIndexRef.current + 1)\n\n      // Auto-launch after brief pause\n      gameStateRef.current = 'playing'\n      onStateChange?.('playing')\n      lastFrameTimeRef.current = performance.now()\n      animationFrameRef.current = requestAnimationFrame(gameLoop)\n      forceRender()\n    }\n  }, [levels.length, initLevel, onLevelChange, onStateChange, gameLoop])\n\n  const movePaddle = React.useCallback((direction: 'left' | 'right' | 'none') => {\n    paddleDirectionRef.current = direction\n    paddleRef.current.targetX = null\n  }, [])\n\n  const setPaddlePosition = React.useCallback((x: number) => {\n    paddleRef.current.targetX = x\n    paddleDirectionRef.current = 'none'\n  }, [])\n\n  const launchBallAction = React.useCallback(() => {\n    if (!ballRef.current.isLaunched && gameStateRef.current === 'playing') {\n      ballRef.current = launchBallFromPaddle(ballRef.current)\n      forceRender()\n    }\n  }, [])\n\n  // Create snapshot for rendering\n  const currentLevel = levels[levelIndexRef.current] || levels[0]\n  const snapshot: GameSnapshot = {\n    state: gameStateRef.current,\n    level: levelIndexRef.current + 1,\n    levelName: currentLevel?.name || `Level ${levelIndexRef.current + 1}`,\n    score: scoreRef.current,\n    highScore: highScoreRef.current,\n    lives: livesRef.current,\n    bricks: bricksRef.current,\n    paddle: paddleRef.current,\n    ball: ballRef.current,\n    combo: comboRef.current,\n    totalLevels: levels.length,\n  }\n\n  return {\n    snapshot,\n    startGame,\n    pauseGame,\n    resumeGame,\n    resetGame,\n    nextLevel,\n    movePaddle,\n    setPaddlePosition,\n    launchBall: launchBallAction,\n  }\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "hooks/use-local-storage.ts",
      "content": "'use client'\n\nimport * as React from 'react'\n\n/**\n * React hook for syncing state with localStorage.\n * Provides automatic serialization, SSR safety, and cross-tab sync.\n *\n * @example\n * ```tsx\n * const [value, setValue] = useLocalStorage('my-key', 'default')\n * ```\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] {\n  // Get initial value from localStorage or use provided initial value\n  const getStoredValue = React.useCallback((): T => {\n    if (typeof window === 'undefined') {\n      return initialValue\n    }\n\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? (JSON.parse(item) as T) : initialValue\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error)\n      return initialValue\n    }\n  }, [key, initialValue])\n\n  const [storedValue, setStoredValue] = React.useState<T>(getStoredValue)\n\n  // Update localStorage when state changes\n  const setValue: React.Dispatch<React.SetStateAction<T>> = React.useCallback(\n    (value) => {\n      try {\n        const valueToStore =\n          value instanceof Function ? value(storedValue) : value\n\n        setStoredValue(valueToStore)\n\n        if (typeof window !== 'undefined') {\n          window.localStorage.setItem(key, JSON.stringify(valueToStore))\n        }\n      } catch (error) {\n        console.warn(`Error setting localStorage key \"${key}\":`, error)\n      }\n    },\n    [key, storedValue]\n  )\n\n  // Sync with localStorage changes from other tabs\n  React.useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key && event.newValue !== null) {\n        try {\n          setStoredValue(JSON.parse(event.newValue) as T)\n        } catch (error) {\n          console.warn(`Error parsing localStorage change for \"${key}\":`, error)\n        }\n      }\n    }\n\n    window.addEventListener('storage', handleStorageChange)\n    return () => window.removeEventListener('storage', handleStorageChange)\n  }, [key])\n\n  return [storedValue, setValue]\n}\n\n/**\n * Simple localStorage helpers for non-reactive access\n */\nexport const storage = {\n  get<T>(key: string, defaultValue: T): T {\n    if (typeof window === 'undefined') return defaultValue\n    try {\n      const item = localStorage.getItem(key)\n      return item ? (JSON.parse(item) as T) : defaultValue\n    } catch {\n      return defaultValue\n    }\n  },\n\n  set<T>(key: string, value: T): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.setItem(key, JSON.stringify(value))\n    } catch {\n      // Silently fail (e.g., quota exceeded)\n    }\n  },\n\n  remove(key: string): void {\n    if (typeof window === 'undefined') return\n    try {\n      localStorage.removeItem(key)\n    } catch {\n      // Silently fail\n    }\n  },\n}\n\n",
      "type": "registry:hook"
    }
  ]
}