{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-sequence",
  "type": "registry:component",
  "title": "Image Sequence",
  "description": "A canvas-based image sequence player with binary progressive loading for smooth playback.",
  "files": [
    {
      "path": "registry/joyco/blocks/image-sequence.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\n\n/* -------------------------------------------------------------------------------------------------\n * Types\n * -------------------------------------------------------------------------------------------------*/\n\ntype SequenceState = {\n  /** Map of loaded images by frame index */\n  images: Map<number, HTMLImageElement>\n  /** Whether the initial frames (first and last) are loaded */\n  initialFramesLoaded: boolean\n  /** Total number of frames loaded */\n  loadedCount: number\n  /** Total frame count */\n  frameCount: number\n}\n\ntype UseSequenceOptions = {\n  /** Total number of frames in the sequence */\n  frameCount: number\n  /** Function to generate the image path for a given frame index */\n  getImagePath: (frameIndex: number) => string\n  /** Whether to start preloading images immediately */\n  preload?: boolean\n  /** Callback when a frame is loaded */\n  onFrameLoad?: (frameIndex: number, image: HTMLImageElement) => void\n  /** Callback when all frames are loaded */\n  onAllFramesLoaded?: () => void\n}\n\ntype UseSequenceReturn = {\n  /** Current sequence state */\n  state: SequenceState\n  /** Get the image for a specific frame index */\n  getFrame: (frameIndex: number) => HTMLImageElement | undefined\n  /** Get the frame index for a given progress value (0-1) */\n  getFrameIndexByProgress: (progress: number) => number\n  /** Get the image for a given progress value (0-1) */\n  getFrameByProgress: (progress: number) => HTMLImageElement | undefined\n  /** Check if a specific frame is loaded */\n  isFrameLoaded: (frameIndex: number) => boolean\n  /** Manually trigger loading of all frames */\n  loadAllFrames: () => void\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Binary Loading Strategy\n * -------------------------------------------------------------------------------------------------\n * Instead of loading frames sequentially or at fixed intervals, we use a binary approach:\n * 1. Load first and last frame (indices 0 and frameCount-1)\n * 2. Load the middle frame (frameCount/2)\n * 3. Load the middles of each half (frameCount/4 and 3*frameCount/4)\n * 4. Continue recursively until all frames are loaded\n *\n * This ensures the animation is visible from start to end early, but at low framerate\n * initially, with increasing smoothness as more frames load.\n * -------------------------------------------------------------------------------------------------*/\n\nfunction generateBinaryLoadOrder(frameCount: number): number[] {\n  if (frameCount <= 0) return []\n  if (frameCount === 1) return [0]\n  if (frameCount === 2) return [0, 1]\n\n  const loadOrder: number[] = []\n  const visited = new Set<number>()\n\n  // Start with first and last\n  const queue: Array<[number, number]> = [[0, frameCount - 1]]\n\n  // Add first and last to load order\n  loadOrder.push(0)\n  visited.add(0)\n  loadOrder.push(frameCount - 1)\n  visited.add(frameCount - 1)\n\n  // Process intervals in breadth-first manner\n  while (queue.length > 0) {\n    const [start, end] = queue.shift()!\n\n    if (end - start <= 1) continue\n\n    const mid = Math.floor((start + end) / 2)\n\n    if (!visited.has(mid)) {\n      loadOrder.push(mid)\n      visited.add(mid)\n    }\n\n    // Add sub-intervals to queue\n    queue.push([start, mid])\n    queue.push([mid, end])\n  }\n\n  return loadOrder\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useSequence Hook\n * -------------------------------------------------------------------------------------------------*/\n\nexport function useSequence({\n  frameCount,\n  getImagePath,\n  preload = true,\n  onFrameLoad,\n  onAllFramesLoaded,\n}: UseSequenceOptions): UseSequenceReturn {\n  const imagesRef = React.useRef<Map<number, HTMLImageElement>>(new Map())\n  const loadingRef = React.useRef<Set<number>>(new Set())\n  const hasStartedLoadingRef = React.useRef(false)\n  const getImagePathRef = React.useRef(getImagePath)\n  const onFrameLoadRef = React.useRef(onFrameLoad)\n  const onAllFramesLoadedRef = React.useRef(onAllFramesLoaded)\n\n  React.useEffect(() => {\n    getImagePathRef.current = getImagePath\n    onFrameLoadRef.current = onFrameLoad\n    onAllFramesLoadedRef.current = onAllFramesLoaded\n  })\n\n  const [state, setState] = React.useState<SequenceState>({\n    images: new Map(),\n    initialFramesLoaded: false,\n    loadedCount: 0,\n    frameCount,\n  })\n\n  // Generate binary load order once\n  const loadOrder = React.useMemo(\n    () => generateBinaryLoadOrder(frameCount),\n    [frameCount]\n  )\n\n  // Load a single image\n  const loadImage = React.useCallback(\n    async (frameIndex: number): Promise<HTMLImageElement | null> => {\n      // Skip if already loaded or currently loading\n      if (\n        imagesRef.current.has(frameIndex) ||\n        loadingRef.current.has(frameIndex)\n      ) {\n        return imagesRef.current.get(frameIndex) ?? null\n      }\n\n      loadingRef.current.add(frameIndex)\n\n      try {\n        const url = getImagePathRef.current(frameIndex)\n        const image = new Image()\n\n        await new Promise<void>((resolve, reject) => {\n          const handleLoad = () => {\n            image.removeEventListener('load', handleLoad)\n            image.removeEventListener('error', handleError)\n            resolve()\n          }\n          const handleError = () => {\n            image.removeEventListener('load', handleLoad)\n            image.removeEventListener('error', handleError)\n            reject(new Error(`Failed to load image: ${url}`))\n          }\n          image.addEventListener('load', handleLoad)\n          image.addEventListener('error', handleError)\n          image.src = url\n        })\n\n        imagesRef.current.set(frameIndex, image)\n        loadingRef.current.delete(frameIndex)\n\n        // Update state\n        setState((prev) => {\n          const newImages = new Map(prev.images)\n          newImages.set(frameIndex, image)\n\n          const newLoadedCount = newImages.size\n          const initialFramesLoaded =\n            newImages.has(0) && newImages.has(frameCount - 1)\n\n          return {\n            ...prev,\n            images: newImages,\n            loadedCount: newLoadedCount,\n            initialFramesLoaded,\n          }\n        })\n\n        onFrameLoadRef.current?.(frameIndex, image)\n\n        return image\n      } catch (error) {\n        loadingRef.current.delete(frameIndex)\n        console.error(`Failed to load frame ${frameIndex}:`, error)\n        return null\n      }\n    },\n    [frameCount]\n  )\n\n  // Load all frames in binary order\n  const loadAllFrames = React.useCallback(async () => {\n    if (hasStartedLoadingRef.current) return\n    hasStartedLoadingRef.current = true\n\n    // Load frames in binary order, but process in batches for better performance\n    const batchSize = 4\n    for (let i = 0; i < loadOrder.length; i += batchSize) {\n      const batch = loadOrder.slice(i, i + batchSize)\n      await Promise.all(batch.map((frameIndex) => loadImage(frameIndex)))\n    }\n\n    onAllFramesLoadedRef.current?.()\n  }, [loadOrder, loadImage])\n\n  // Start preloading on mount if enabled\n  React.useEffect(() => {\n    const loading = loadingRef.current\n    const images = imagesRef.current\n\n    if (preload) {\n      loadAllFrames()\n    }\n\n    return () => {\n      // Cleanup: reset loading state and cancel any pending loads\n      hasStartedLoadingRef.current = false\n      loading.clear()\n      images.forEach((img) => {\n        img.src = ''\n      })\n      images.clear()\n    }\n  }, [preload, loadAllFrames])\n\n  // Utility functions\n  const getFrame = React.useCallback(\n    (frameIndex: number) => imagesRef.current.get(frameIndex),\n    []\n  )\n\n  const getFrameIndexByProgress = React.useCallback(\n    (progress: number) => {\n      const clampedProgress = Math.max(0, Math.min(1, progress))\n      return Math.floor(clampedProgress * (frameCount - 1))\n    },\n    [frameCount]\n  )\n\n  const getFrameByProgress = React.useCallback(\n    (progress: number) => {\n      const frameIndex = getFrameIndexByProgress(progress)\n      return imagesRef.current.get(frameIndex)\n    },\n    [getFrameIndexByProgress]\n  )\n\n  const isFrameLoaded = React.useCallback(\n    (frameIndex: number) => imagesRef.current.has(frameIndex),\n    []\n  )\n\n  return {\n    state,\n    getFrame,\n    getFrameIndexByProgress,\n    getFrameByProgress,\n    isFrameLoaded,\n    loadAllFrames,\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * CanvasSequence Component\n * -------------------------------------------------------------------------------------------------\n * Renders an image sequence to a canvas element. This approach:\n * - Decodes images at paint time (prevents half-decoded visible images)\n * - Blocks rendering until the required frame is available\n * - Provides smoother playback than toggling img visibility\n * -------------------------------------------------------------------------------------------------*/\n\ninterface CanvasSequenceProps extends Omit<\n  React.CanvasHTMLAttributes<HTMLCanvasElement>,\n  'children' | 'width' | 'height'\n> {\n  /** Total number of frames in the sequence */\n  frameCount: number\n  /** Duration of each frame in milliseconds */\n  frameDuration: number\n  /** Function to generate the image path for a given frame index */\n  getImagePath: (frameIndex: number) => string\n  /** Whether the animation is currently playing */\n  isPlaying?: boolean\n  /** Whether to loop the animation */\n  loop?: boolean\n  /** Whether to preload images */\n  preload?: boolean\n  /** Object fit behavior */\n  objectFit?: 'contain' | 'cover' | 'fill'\n  /** Callback when a frame is rendered */\n  onFrameChange?: (frameIndex: number) => void\n  /** Callback when all frames are loaded */\n  onAllFramesLoaded?: () => void\n  /** Transform time delta (for speed control) */\n  timeTransform?: (deltaTime: number) => number\n  /** Device pixel ratio for high-DPI displays */\n  devicePixelRatio?: number\n  /** Reset animation to frame 0 when playback starts */\n  resetOnPlay?: boolean\n  /**\n   * Optional wrapper width (in CSS px). If omitted, the component will size itself\n   * from its parent layout (recommended).\n   */\n  width?: number\n  /**\n   * Optional wrapper height (in CSS px). If omitted, the component will size itself\n   * from its parent layout (recommended).\n   */\n  height?: number\n}\n\nexport function CanvasSequence({\n  frameCount,\n  frameDuration,\n  getImagePath,\n  isPlaying = true,\n  loop = true,\n  preload = true,\n  objectFit = 'contain',\n  onFrameChange,\n  onAllFramesLoaded,\n  timeTransform,\n  devicePixelRatio,\n  resetOnPlay = false,\n  width: initialWidth,\n  height: initialHeight,\n  className,\n  style,\n  ...props\n}: CanvasSequenceProps) {\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  const canvasRef = React.useRef<HTMLCanvasElement>(null)\n  const ctxRef = React.useRef<CanvasRenderingContext2D | null>(null)\n  const currentFrameRef = React.useRef<number>(-1)\n  const timePassedRef = React.useRef<number>(0)\n  const animationFrameRef = React.useRef<number | null>(null)\n  const lastTimeRef = React.useRef<number | null>(null)\n  const wasPlayingRef = React.useRef<boolean>(isPlaying)\n  const onFrameChangeRef = React.useRef(onFrameChange)\n  const timeTransformRef = React.useRef(timeTransform)\n  const [bounds, setBounds] = React.useState(() => ({\n    width: initialWidth ?? 0,\n    height: initialHeight ?? 0,\n  }))\n\n  React.useEffect(() => {\n    onFrameChangeRef.current = onFrameChange\n    timeTransformRef.current = timeTransform\n  })\n\n  const totalDuration = frameCount * frameDuration\n\n  // Use the sequence hook\n  const { state, getFrame, getFrameIndexByProgress, loadAllFrames } =\n    useSequence({\n      frameCount,\n      getImagePath,\n      preload,\n      onAllFramesLoaded,\n    })\n\n  // If playing but nothing has been preloaded, trigger loading\n  React.useEffect(() => {\n    if (isPlaying && !state.initialFramesLoaded && state.loadedCount === 0) {\n      loadAllFrames()\n    }\n  }, [isPlaying, state.initialFramesLoaded, state.loadedCount, loadAllFrames])\n\n  // Get actual pixel ratio\n  const dpr =\n    devicePixelRatio ??\n    (typeof window !== 'undefined' ? window.devicePixelRatio : 1)\n\n  // Measure wrapper bounds and keep canvas synced to those bounds.\n  React.useEffect(() => {\n    const el = containerRef.current\n    if (!el) return\n\n    const measure = () => {\n      const rect = el.getBoundingClientRect()\n      const nextWidth = Math.max(0, Math.floor(rect.width))\n      const nextHeight = Math.max(0, Math.floor(rect.height))\n\n      setBounds((prev) => {\n        if (prev.width === nextWidth && prev.height === nextHeight) return prev\n        return { width: nextWidth, height: nextHeight }\n      })\n    }\n\n    measure()\n    const ro = new ResizeObserver(measure)\n    ro.observe(el)\n    return () => ro.disconnect()\n  }, [])\n\n  const width = bounds.width\n  const height = bounds.height\n\n  // Setup canvas context\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n    if (width <= 0 || height <= 0) return\n\n    // Set canvas size accounting for device pixel ratio\n    canvas.width = width * dpr\n    canvas.height = height * dpr\n\n    const ctx = canvas.getContext('2d')\n    if (ctx) {\n      // Avoid accumulating transforms across resizes\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)\n      ctxRef.current = ctx\n    }\n  }, [width, height, dpr])\n\n  // Paint a frame to the canvas\n  const paintFrame = React.useCallback(\n    (frameIndex: number) => {\n      const ctx = ctxRef.current\n      const canvas = canvasRef.current\n      if (!ctx || !canvas) return false\n      if (width <= 0 || height <= 0) return false\n\n      const image = getFrame(frameIndex)\n      if (!image) return false\n\n      // Clear canvas\n      ctx.clearRect(0, 0, width, height)\n\n      // Calculate draw dimensions based on object-fit\n      let drawX = 0\n      let drawY = 0\n      let drawWidth = width\n      let drawHeight = height\n\n      const imageAspect = image.naturalWidth / image.naturalHeight\n      const canvasAspect = width / height\n\n      if (objectFit === 'contain') {\n        if (imageAspect > canvasAspect) {\n          drawHeight = width / imageAspect\n          drawY = (height - drawHeight) / 2\n        } else {\n          drawWidth = height * imageAspect\n          drawX = (width - drawWidth) / 2\n        }\n      } else if (objectFit === 'cover') {\n        if (imageAspect > canvasAspect) {\n          drawWidth = height * imageAspect\n          drawX = (width - drawWidth) / 2\n        } else {\n          drawHeight = width / imageAspect\n          drawY = (height - drawHeight) / 2\n        }\n      }\n      // 'fill' uses default full canvas dimensions\n\n      ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight)\n\n      if (currentFrameRef.current !== frameIndex) {\n        currentFrameRef.current = frameIndex\n        onFrameChangeRef.current?.(frameIndex)\n      }\n\n      return true\n    },\n    [getFrame, width, height, objectFit]\n  )\n\n  // Find the closest available frame (for when exact frame isn't loaded yet)\n  const findClosestLoadedFrame = React.useCallback(\n    (targetFrame: number): number | null => {\n      if (state.images.has(targetFrame)) return targetFrame\n\n      // Search outward from target frame\n      for (let offset = 1; offset < frameCount; offset++) {\n        const before = targetFrame - offset\n        const after = targetFrame + offset\n\n        if (before >= 0 && state.images.has(before)) return before\n        if (after < frameCount && state.images.has(after)) return after\n      }\n\n      return null\n    },\n    [state.images, frameCount]\n  )\n\n  // Animation loop\n  React.useEffect(() => {\n    if (!isPlaying) {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n        animationFrameRef.current = null\n      }\n      lastTimeRef.current = null\n      return\n    }\n\n    // Wait for initial frames to be loaded before starting animation\n    if (!state.initialFramesLoaded) return\n\n    const tick = (timestamp: number) => {\n      if (lastTimeRef.current === null) {\n        lastTimeRef.current = timestamp\n        animationFrameRef.current = requestAnimationFrame(tick)\n        return\n      }\n\n      let deltaTime = timestamp - lastTimeRef.current\n      lastTimeRef.current = timestamp\n\n      // Apply time transform if provided\n      if (timeTransformRef.current) {\n        deltaTime = timeTransformRef.current(deltaTime)\n      }\n\n      timePassedRef.current += deltaTime\n\n      // Calculate progress\n      let progress: number\n      if (loop) {\n        progress = (timePassedRef.current % totalDuration) / totalDuration\n      } else {\n        progress = Math.min(timePassedRef.current / totalDuration, 1)\n      }\n\n      const targetFrame = getFrameIndexByProgress(progress)\n      const frameToRender = findClosestLoadedFrame(targetFrame)\n\n      if (frameToRender !== null) {\n        paintFrame(frameToRender)\n      }\n\n      // Continue animation if looping or not finished\n      if (loop || progress < 1) {\n        animationFrameRef.current = requestAnimationFrame(tick)\n      }\n    }\n\n    animationFrameRef.current = requestAnimationFrame(tick)\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n        animationFrameRef.current = null\n      }\n    }\n  }, [\n    isPlaying,\n    loop,\n    state.initialFramesLoaded,\n    totalDuration,\n    getFrameIndexByProgress,\n    findClosestLoadedFrame,\n    paintFrame,\n  ])\n\n  // Reset animation when sequence config changes\n  React.useEffect(() => {\n    timePassedRef.current = 0\n    currentFrameRef.current = -1\n    lastTimeRef.current = null\n  }, [frameCount, frameDuration])\n\n  // Reset animation when playback starts (if resetOnPlay is enabled)\n  React.useEffect(() => {\n    const wasPlaying = wasPlayingRef.current\n    wasPlayingRef.current = isPlaying\n\n    if (resetOnPlay && isPlaying && !wasPlaying) {\n      timePassedRef.current = 0\n      currentFrameRef.current = -1\n      lastTimeRef.current = null\n    }\n  }, [isPlaying, resetOnPlay])\n\n  // Paint first frame when available (for non-playing state)\n  React.useEffect(() => {\n    if (!isPlaying && state.images.has(0)) {\n      paintFrame(0)\n    }\n  }, [isPlaying, state.images, paintFrame])\n\n  return (\n    <div\n      ref={containerRef}\n      data-slot=\"canvas-sequence\"\n      className={cn('relative size-full', className)}\n      style={{\n        width: initialWidth,\n        height: initialHeight,\n        ...style,\n      }}\n    >\n      <canvas\n        ref={canvasRef}\n        data-slot=\"canvas\"\n        className=\"absolute inset-0 block size-full\"\n        {...props}\n      />\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}