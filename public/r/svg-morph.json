{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "svg-morph",
  "type": "registry:component",
  "title": "SVG Morph",
  "description": "Smooth SVG path morphing animations with flubber interpolation. Supports auto-looping and controlled step mode.",
  "dependencies": [
    "flubber",
    "motion"
  ],
  "files": [
    {
      "path": "registry/joyco/blocks/svg-morph.tsx",
      "content": "'use client'\n\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport { interpolate } from 'flubber'\nimport { animate, motion, useMotionValue, useTransform } from 'motion/react'\n\ntype FlubberInterpolator = (t: number) => string\n\ninterface SvgMorphPathProps {\n  paths: string[]\n  duration?: number\n  gap?: number\n  fill?: string\n  step?: number\n}\n\nfunction AutoMorphPath({\n  paths,\n  duration,\n  gap,\n  fill,\n}: {\n  paths: string[]\n  duration: number\n  gap: number\n  fill: string\n}) {\n  const [pathIndex, setPathIndex] = useState(0)\n  const progress = useMotionValue(pathIndex)\n\n  const loopedPaths = useMemo(() => [...paths, paths[0]], [paths])\n  const indices = useMemo(() => loopedPaths.map((_, i) => i), [loopedPaths])\n  const d = useTransform(progress, indices, loopedPaths, {\n    mixer: (a, b) => interpolate(a, b, { maxSegmentLength: 20 }),\n  })\n\n  useEffect(() => {\n    const animation = animate(progress, pathIndex, {\n      duration,\n      ease: 'easeInOut',\n      delay: gap,\n      onComplete: () => {\n        if (pathIndex === loopedPaths.length - 1) {\n          progress.set(0)\n          setPathIndex(1)\n        } else {\n          setPathIndex(pathIndex + 1)\n        }\n      },\n    })\n\n    return () => animation.stop()\n  }, [pathIndex, duration, gap, loopedPaths, progress])\n\n  return <motion.path fill={fill} d={d} />\n}\n\nfunction ControlledMorphPath({\n  paths,\n  duration,\n  fill,\n  step,\n}: {\n  paths: string[]\n  duration: number\n  fill: string\n  step: number\n}) {\n  const progress = useMotionValue(0)\n  const currentPathRef = useRef(paths[step])\n  const interpolatorRef = useRef<FlubberInterpolator | null>(null)\n\n  const d = useTransform(progress, (v: number) => {\n    if (!interpolatorRef.current) return currentPathRef.current\n    return interpolatorRef.current(v)\n  })\n\n  useEffect(() => {\n    const targetPath = paths[step]\n    if (targetPath === currentPathRef.current) return\n\n    // Capture mid-animation state if interrupted\n    const p = progress.get()\n    if (interpolatorRef.current && p > 0 && p < 1) {\n      currentPathRef.current = interpolatorRef.current(p)\n    }\n\n    // Direct interpolation: current visual state â†’ target (skips intermediates)\n    interpolatorRef.current = interpolate(\n      currentPathRef.current,\n      targetPath,\n      { maxSegmentLength: 20 }\n    )\n    progress.set(0)\n\n    const animation = animate(progress, 1, {\n      duration,\n      ease: 'easeInOut',\n      onComplete: () => {\n        currentPathRef.current = targetPath\n        interpolatorRef.current = null\n      },\n    })\n\n    return () => animation.stop()\n  }, [step, duration, progress, paths])\n\n  return <motion.path fill={fill} d={d} />\n}\n\nfunction SvgMorphPath({\n  paths,\n  duration = 0.4,\n  gap = 0.5,\n  fill = 'currentColor',\n  step,\n}: SvgMorphPathProps) {\n  if (step !== undefined) {\n    return (\n      <ControlledMorphPath\n        paths={paths}\n        duration={duration}\n        fill={fill}\n        step={step}\n      />\n    )\n  }\n\n  return (\n    <AutoMorphPath\n      paths={paths}\n      duration={duration}\n      gap={gap}\n      fill={fill}\n    />\n  )\n}\n\ninterface StaticPath {\n  d: string\n  fill?: string\n}\n\ninterface SvgMorphProps {\n  svgs: {\n    paths: string[]\n    fill?: string\n  }[]\n  staticPaths?: StaticPath[]\n  viewBox: string\n  transform?: string\n  duration?: number\n  gap?: number\n  step?: number\n  className?: string\n  width?: number | string\n  height?: number | string\n}\n\nexport default function SvgMorph({\n  svgs,\n  staticPaths,\n  viewBox,\n  transform,\n  duration,\n  gap,\n  step,\n  className,\n  width,\n  height,\n}: SvgMorphProps) {\n  const children = (\n    <>\n      {staticPaths?.map((sp, i) => (\n        <path key={`static-${i}`} d={sp.d} fill={sp.fill ?? 'currentColor'} />\n      ))}\n      {svgs.map((svg, i) => (\n        <SvgMorphPath\n          key={i}\n          paths={svg.paths}\n          fill={svg.fill}\n          duration={duration}\n          gap={gap}\n          step={step}\n        />\n      ))}\n    </>\n  )\n\n  return (\n    <svg\n      viewBox={viewBox}\n      className={className}\n      width={width}\n      height={height}\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      {transform ? <g transform={transform}>{children}</g> : children}\n    </svg>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "hooks/use-svg-morph.ts",
      "content": "'use client'\n\nimport { useState, useCallback } from 'react'\n\nexport interface UseSvgMorphOptions {\n  totalSteps: number\n  initialStep?: number\n}\n\nexport interface UseSvgMorphReturn {\n  step: number\n  setStep: (step: number) => void\n  next: () => void\n  prev: () => void\n  isFirst: boolean\n  isLast: boolean\n}\n\nexport function useSvgMorph({\n  totalSteps,\n  initialStep = 0,\n}: UseSvgMorphOptions): UseSvgMorphReturn {\n  const [step, setStepRaw] = useState(initialStep)\n\n  const clamp = useCallback(\n    (value: number) => Math.max(0, Math.min(value, totalSteps - 1)),\n    [totalSteps]\n  )\n\n  const setStep = useCallback(\n    (value: number) => setStepRaw(clamp(value)),\n    [clamp]\n  )\n\n  const next = useCallback(\n    () => setStepRaw((s) => clamp(s + 1)),\n    [clamp]\n  )\n\n  const prev = useCallback(\n    () => setStepRaw((s) => clamp(s - 1)),\n    [clamp]\n  )\n\n  return {\n    step,\n    setStep,\n    next,\n    prev,\n    isFirst: step === 0,\n    isLast: step === totalSteps - 1,\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}