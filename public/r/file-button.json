{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "file-button",
  "type": "registry:component",
  "title": "File Button",
  "description": "A button that opens a file input when clicked.",
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/joyco/blocks/file-button.tsx",
      "content": "'use client'\nimport { Button } from '@/components/ui/button'\nimport { useFileUpload } from '@/hooks/use-file-upload'\n\nexport interface FileInputProps {\n  onUpload: (file: File) => Promise<unknown> | void\n  inputProps?: React.InputHTMLAttributes<HTMLInputElement>\n}\n\nexport const FileInputButton = (\n  props: FileInputProps & React.ComponentProps<typeof Button>\n) => {\n  const { inputProps, onUpload, children, ...buttonProps } = props\n  const { openFileDialog, getInputProps } = useFileUpload({ onUpload })\n\n  return (\n    <Button onClick={openFileDialog} {...buttonProps}>\n      <input {...getInputProps()} {...inputProps} className=\"sr-only\" />\n      {children}\n    </Button>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "hooks/use-file-upload.tsx",
      "content": "import { useCallback, useId, useRef, useState } from 'react'\n\nexport interface FileWithPreview {\n  id: string\n  file: File\n  preview?: string\n}\n\nexport interface UseFileUploadOptions {\n  accept?: string\n  maxSize?: number\n  maxFiles?: number\n  onUpload?: (file: File) => Promise<unknown> | void\n}\n\nexport interface UseFileUploadReturn {\n  files: FileWithPreview[]\n  errors: string[]\n  isDragging: boolean\n  removeFile: (id: string) => void\n  openFileDialog: () => void\n  getInputProps: () => {\n    ref: React.RefObject<HTMLInputElement | null>\n    type: 'file'\n    id: string\n    accept?: string\n    multiple: boolean\n    onChange: (event: React.ChangeEvent<HTMLInputElement>) => Promise<void>\n  }\n  handleDragEnter: (e: React.DragEvent) => void\n  handleDragLeave: (e: React.DragEvent) => void\n  handleDragOver: (e: React.DragEvent) => void\n  handleDrop: (e: React.DragEvent) => void\n}\n\nexport function useFileUpload(\n  options: UseFileUploadOptions = {}\n): UseFileUploadReturn {\n  const { accept, maxSize, maxFiles = 1, onUpload } = options\n\n  const id = useId()\n  const inputRef = useRef<HTMLInputElement>(null)\n  const dragCounterRef = useRef(0)\n\n  const [files, setFiles] = useState<FileWithPreview[]>([])\n  const [errors, setErrors] = useState<string[]>([])\n  const [isDragging, setIsDragging] = useState(false)\n\n  const validateFile = useCallback(\n    (file: File): string | null => {\n      if (accept) {\n        const acceptedTypes = accept.split(',').map((t) => t.trim())\n        const fileType = file.type\n        const isAccepted = acceptedTypes.some((type) => {\n          if (type.endsWith('/*')) {\n            return fileType.startsWith(type.replace('/*', ''))\n          }\n          return fileType === type\n        })\n\n        if (!isAccepted) {\n          return `File type not accepted. Allowed: ${accept}`\n        }\n      }\n\n      if (maxSize && file.size > maxSize) {\n        const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(1)\n        return `File too large. Max size: ${maxSizeMB}MB`\n      }\n\n      return null\n    },\n    [accept, maxSize]\n  )\n\n  const createPreview = useCallback(\n    (file: File): Promise<string | undefined> => {\n      return new Promise((resolve) => {\n        if (file.type.startsWith('image/')) {\n          const reader = new FileReader()\n          reader.onloadend = () => resolve(reader.result as string)\n          reader.onerror = () => resolve(undefined)\n          reader.readAsDataURL(file)\n        } else {\n          resolve(undefined)\n        }\n      })\n    },\n    []\n  )\n\n  const processFiles = useCallback(\n    async (fileList: FileList | File[]) => {\n      const filesArray = Array.from(fileList)\n      const newErrors: string[] = []\n      const validFiles: FileWithPreview[] = []\n\n      for (const file of filesArray) {\n        const error = validateFile(file)\n        if (error) {\n          newErrors.push(error)\n          continue\n        }\n\n        const preview = await createPreview(file)\n\n        validFiles.push({\n          id: `${Date.now()}-${Math.random()}`,\n          file,\n          preview,\n        })\n\n        if (onUpload) {\n          await onUpload(file)\n        }\n      }\n\n      setErrors(newErrors)\n      setFiles((prev) => {\n        const combined = [...prev, ...validFiles]\n        return combined.slice(0, maxFiles)\n      })\n    },\n    [validateFile, createPreview, onUpload, maxFiles]\n  )\n\n  const removeFile = useCallback((fileId: string) => {\n    setFiles((prev) => prev.filter((f) => f.id !== fileId))\n  }, [])\n\n  const openFileDialog = useCallback(() => {\n    inputRef.current?.click()\n  }, [])\n\n  const handleFileChange = useCallback(\n    async (event: React.ChangeEvent<HTMLInputElement>) => {\n      const fileList = event.target.files\n      if (fileList && fileList.length > 0) {\n        await processFiles(fileList)\n      }\n      event.target.value = ''\n    },\n    [processFiles]\n  )\n\n  const getInputProps = useCallback(() => {\n    return {\n      ref: inputRef,\n      type: 'file' as const,\n      id: `${id}-file-input`,\n      accept,\n      multiple: maxFiles > 1,\n      onChange: handleFileChange,\n    }\n  }, [id, accept, maxFiles, handleFileChange])\n\n  const handleDragEnter = useCallback((e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    dragCounterRef.current++\n    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n      setIsDragging(true)\n    }\n  }, [])\n\n  const handleDragLeave = useCallback((e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    dragCounterRef.current--\n    if (dragCounterRef.current === 0) {\n      setIsDragging(false)\n    }\n  }, [])\n\n  const handleDragOver = useCallback((e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n  }, [])\n\n  const handleDrop = useCallback(\n    async (e: React.DragEvent) => {\n      e.preventDefault()\n      e.stopPropagation()\n      setIsDragging(false)\n      dragCounterRef.current = 0\n\n      const fileList = e.dataTransfer.files\n      if (fileList && fileList.length > 0) {\n        await processFiles(fileList)\n      }\n    },\n    [processFiles]\n  )\n\n  return {\n    files,\n    errors,\n    isDragging,\n    removeFile,\n    openFileDialog,\n    getInputProps,\n    handleDragEnter,\n    handleDragLeave,\n    handleDragOver,\n    handleDrop,\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}