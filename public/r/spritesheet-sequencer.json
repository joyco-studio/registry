{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "spritesheet-sequencer",
  "type": "registry:component",
  "title": "Spritesheet Sequencer",
  "description": "A WAAPI-powered spritesheet animator for squared grid-based spritesheets with stepped frame animation.",
  "files": [
    {
      "path": "registry/joyco/blocks/spritesheet-sequencer.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\n\n/* -------------------------------------------------------------------------------------------------\n * Types\n * -------------------------------------------------------------------------------------------------*/\n\nexport interface SpritesheetSequencerProps extends React.ComponentProps<'div'> {\n  /** URL to the squared spritesheet image */\n  src: string\n  /** Total number of frames in the spritesheet */\n  frameCount: number\n  /** Duration per frame in milliseconds (default: 100) */\n  frameDuration?: number\n  /** Whether the animation is playing (default: true) */\n  isPlaying?: boolean\n  /** Whether to loop the animation (default: true) */\n  loop?: boolean\n  /** Animation direction (default: 'normal') */\n  direction?: 'normal' | 'reverse' | 'alternate' | 'alternate-reverse'\n  /** Reset to frame 0 when isPlaying changes to true (default: false) */\n  resetOnPlay?: boolean\n  /** Callback fired when the current frame changes */\n  onFrameChange?: (frame: number) => void\n  /** Callback fired when the spritesheet image loads */\n  onLoad?: () => void\n  /** Callback fired when the animation completes (non-looping only) */\n  onComplete?: () => void\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Helpers\n * -------------------------------------------------------------------------------------------------*/\n\nfunction buildKeyframes(frameCount: number, gridSize: number): Keyframe[] {\n  const keyframes: Keyframe[] = []\n\n  for (let i = 0; i < frameCount; i++) {\n    const col = i % gridSize\n    const row = Math.floor(i / gridSize)\n\n    // CSS background-position % is relative to (container - image) size\n    // 0% = left/top edge aligned, 100% = right/bottom edge aligned\n    // For gridSize columns, we need to map col 0 to 0%, col (gridSize-1) to 100%\n    const posX = gridSize > 1 ? (col / (gridSize - 1)) * 100 : 0\n    const posY = gridSize > 1 ? (row / (gridSize - 1)) * 100 : 0\n\n    keyframes.push({\n      backgroundPositionX: `${posX}%`,\n      backgroundPositionY: `${posY}%`,\n      offset: i / frameCount,\n      easing: 'step-end',\n    })\n  }\n\n  return keyframes\n}\n\n/* -------------------------------------------------------------------------------------------------\n * SpritesheetSequencer\n * -------------------------------------------------------------------------------------------------*/\n\nexport function SpritesheetSequencer({\n  src,\n  frameCount,\n  frameDuration = 100,\n  isPlaying = true,\n  loop = true,\n  direction = 'normal',\n  resetOnPlay = false,\n  onFrameChange,\n  onLoad,\n  onComplete,\n  className,\n  style,\n  ...props\n}: SpritesheetSequencerProps) {\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  const animationRef = React.useRef<Animation | null>(null)\n  const currentFrameRef = React.useRef<number>(-1)\n  const wasPlayingRef = React.useRef<boolean>(isPlaying)\n  const onFrameChangeRef = React.useRef(onFrameChange)\n  const onCompleteRef = React.useRef(onComplete)\n  const onLoadRef = React.useRef(onLoad)\n\n  const [isLoaded, setIsLoaded] = React.useState(false)\n\n  const gridSize = Math.ceil(Math.sqrt(frameCount))\n  const totalDuration = frameDuration * frameCount\n\n  // Keep refs in sync\n  React.useEffect(() => {\n    onFrameChangeRef.current = onFrameChange\n    onCompleteRef.current = onComplete\n    onLoadRef.current = onLoad\n  })\n\n  // Preload spritesheet image\n  React.useEffect(() => {\n    const img = new Image()\n\n    const handleLoad = () => {\n      setIsLoaded(true)\n      onLoadRef.current?.()\n    }\n\n    const handleError = () => {\n      console.error(`Failed to load spritesheet: ${src}`)\n    }\n\n    img.addEventListener('load', handleLoad)\n    img.addEventListener('error', handleError)\n    img.src = src\n\n    return () => {\n      img.removeEventListener('load', handleLoad)\n      img.removeEventListener('error', handleError)\n      img.src = ''\n    }\n  }, [src])\n\n  // Create animation (only recreate when structure changes, not timing)\n  React.useEffect(() => {\n    if (!isLoaded || !containerRef.current) return\n    if (frameCount <= 0) return\n\n    const keyframes = buildKeyframes(frameCount, gridSize)\n\n    const animation = containerRef.current.animate(keyframes, {\n      duration: frameDuration * frameCount,\n      iterations: loop ? Infinity : 1,\n      direction,\n      fill: 'forwards',\n    })\n\n    // Start paused if not playing\n    if (!isPlaying) {\n      animation.pause()\n    }\n\n    // Handle animation completion (non-looping)\n    animation.onfinish = () => {\n      onCompleteRef.current?.()\n    }\n\n    animationRef.current = animation\n    currentFrameRef.current = -1\n\n    return () => {\n      animation.cancel()\n      animationRef.current = null\n    }\n    // Note: frameDuration intentionally excluded - handled by separate effect\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoaded, frameCount, gridSize, loop, direction])\n\n  // Handle play/pause changes\n  React.useEffect(() => {\n    const animation = animationRef.current\n    if (!animation) return\n\n    if (isPlaying) {\n      // Reset if requested and transitioning from paused to playing\n      if (resetOnPlay && !wasPlayingRef.current) {\n        animation.currentTime = 0\n        currentFrameRef.current = -1\n      }\n      animation.play()\n    } else {\n      animation.pause()\n    }\n\n    wasPlayingRef.current = isPlaying\n  }, [isPlaying, resetOnPlay])\n\n  // Update duration dynamically without recreating animation\n  React.useEffect(() => {\n    const animation = animationRef.current\n    if (!animation?.effect) return\n\n    const timing = animation.effect.getTiming()\n    const oldDuration = timing.duration as number\n    const newDuration = totalDuration\n\n    // Skip if duration hasn't changed or is invalid\n    if (oldDuration === newDuration || !oldDuration || !newDuration) return\n\n    // Preserve relative progress when changing speed\n    const currentTime = Number(animation.currentTime ?? 0)\n    const currentProgress = currentTime / oldDuration\n    animation.effect.updateTiming({ duration: newDuration })\n    animation.currentTime = currentProgress * newDuration\n  }, [totalDuration])\n\n  // Track frame changes via RAF\n  React.useEffect(() => {\n    if (!isPlaying || !animationRef.current || !frameDuration || !frameCount) return\n\n    let rafId: number\n\n    const tick = () => {\n      const animation = animationRef.current\n      if (!animation) return\n\n      const currentTime = Number(animation.currentTime ?? 0)\n      const frame = Math.floor(currentTime / frameDuration) % frameCount\n\n      if (frame !== currentFrameRef.current) {\n        currentFrameRef.current = frame\n        onFrameChangeRef.current?.(frame)\n      }\n\n      rafId = requestAnimationFrame(tick)\n    }\n\n    rafId = requestAnimationFrame(tick)\n\n    return () => {\n      cancelAnimationFrame(rafId)\n    }\n  }, [isPlaying, frameDuration, frameCount])\n\n  return (\n    <div\n      ref={containerRef}\n      role=\"img\"\n      data-slot=\"spritesheet-sequencer\"\n      data-loaded={isLoaded}\n      data-playing={isPlaying && isLoaded}\n      className={cn('size-full bg-no-repeat', className)}\n      style={{\n        backgroundImage: isLoaded ? `url(${src})` : undefined,\n        backgroundSize: `${gridSize * 100}% ${gridSize * 100}%`,\n        ...style,\n      }}\n      {...props}\n    />\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}