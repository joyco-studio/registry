{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "typewriter",
  "type": "registry:component",
  "title": "Typewriter",
  "description": "A lightweight typewriter text component that cycles through phrases with minimal JavaScript.",
  "files": [
    {
      "path": "registry/joyco/blocks/typewriter.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\nimport { useTypewriter } from '@/hooks/use-typewriter'\n\nexport interface TypewriterProps extends React.ComponentPropsWithRef<'span'> {\n  texts: readonly string[]\n  msPerChar?: number\n  pauseMs?: number\n  deleteMsPerChar?: number\n  gapMs?: number\n  loop?: boolean\n  caret?: boolean\n}\n\nexport function Typewriter({\n  texts,\n  msPerChar = 60,\n  pauseMs = 900,\n  deleteMsPerChar = msPerChar,\n  gapMs = 150,\n  loop = true,\n  caret = true,\n  className,\n  ref,\n  ...props\n}: TypewriterProps) {\n  const { visible, longestText, prefersReducedMotion } = useTypewriter({\n    texts,\n    msPerChar,\n    pauseMs,\n    deleteMsPerChar,\n    gapMs,\n    loop,\n  })\n\n  if (texts.length === 0) return null\n\n  return (\n    <span\n      ref={ref}\n      className={cn('relative inline-block', className)}\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      {...props}\n    >\n      {/* Size holder - only renders longest text */}\n      <span\n        data-slot=\"size-holder\"\n        className=\"invisible whitespace-pre\"\n        aria-hidden=\"true\"\n      >\n        {longestText}\n      </span>\n\n      {/* Visible text */}\n      <span data-slot=\"text\" className=\"absolute inset-0 whitespace-pre\">\n        {visible}\n        {caret && (\n          <span\n            data-slot=\"caret\"\n            className=\"inline-block w-px bg-current\"\n            style={{ height: '1em' }}\n            aria-hidden=\"true\"\n          />\n        )}\n      </span>\n    </span>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "hooks/use-typewriter.ts",
      "content": "'use client'\n\nimport * as React from 'react'\n\nexport interface UseTypewriterOptions {\n  texts: readonly string[]\n  msPerChar?: number\n  pauseMs?: number\n  deleteMsPerChar?: number\n  gapMs?: number\n  loop?: boolean\n}\n\nexport interface UseTypewriterReturn {\n  /** The currently visible text */\n  visible: string\n  /** The longest text from the array (useful for sizing) */\n  longestText: string\n  /** Current animation phase */\n  phase: 'type' | 'pause' | 'delete' | 'gap'\n  /** Whether the typewriter is actively animating */\n  isAnimating: boolean\n  /** Whether reduced motion is preferred */\n  prefersReducedMotion: boolean\n}\n\nfunction usePrefersReducedMotion(): boolean {\n  const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(false)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia('(prefers-reduced-motion: reduce)')\n    setPrefersReducedMotion(mql.matches)\n\n    const handler = (event: MediaQueryListEvent) => {\n      setPrefersReducedMotion(event.matches)\n    }\n\n    mql.addEventListener('change', handler)\n    return () => mql.removeEventListener('change', handler)\n  }, [])\n\n  return prefersReducedMotion\n}\n\nexport function useTypewriter({\n  texts,\n  msPerChar = 60,\n  pauseMs = 900,\n  deleteMsPerChar = msPerChar,\n  gapMs = 150,\n  loop = true,\n}: UseTypewriterOptions): UseTypewriterReturn {\n  const prefersReducedMotion = usePrefersReducedMotion()\n  const [index, setIndex] = React.useState(0)\n  const [count, setCount] = React.useState(0)\n  const [phase, setPhase] = React.useState<'type' | 'pause' | 'delete' | 'gap'>(\n    'type'\n  )\n\n  // Clamp index when texts array changes\n  const safeIndex = Math.min(index, Math.max(0, texts.length - 1))\n  const text = texts[safeIndex] ?? ''\n\n  const graphemes = React.useMemo(() => toGraphemes(text), [text])\n\n  // Reset state when texts array changes (reference equality)\n  const textsKey = React.useMemo(() => texts.join('\\0'), [texts])\n  React.useEffect(() => {\n    setIndex(0)\n    setCount(0)\n    setPhase('type')\n  }, [textsKey])\n\n  const isAnimatingRef = React.useRef(true)\n\n  React.useEffect(() => {\n    if (texts.length === 0) {\n      isAnimatingRef.current = false\n      return\n    }\n\n    // Skip animation when user prefers reduced motion\n    if (prefersReducedMotion) {\n      isAnimatingRef.current = false\n      setCount(graphemes.length)\n      setPhase('pause')\n      return\n    }\n\n    isAnimatingRef.current = true\n    let rafId: number\n    let lastTime = performance.now()\n\n    const animate = (currentTime: number) => {\n      const elapsed = currentTime - lastTime\n\n      // Handle empty strings\n      if (graphemes.length === 0) {\n        if (phase === 'type') {\n          setPhase('pause')\n          lastTime = currentTime\n        } else if (phase === 'pause' && elapsed >= pauseMs) {\n          setPhase('delete')\n          lastTime = currentTime\n        } else if (phase === 'delete') {\n          const isLast = safeIndex + 1 >= texts.length\n          if (isLast && !loop) {\n            isAnimatingRef.current = false\n            return\n          }\n          setIndex(isLast ? 0 : safeIndex + 1)\n          setPhase('gap')\n          lastTime = currentTime\n        } else if (phase === 'gap' && elapsed >= gapMs) {\n          setPhase('type')\n          lastTime = currentTime\n        }\n\n        if (phase === 'pause' || phase === 'gap') {\n          rafId = requestAnimationFrame(animate)\n        }\n        return\n      }\n\n      // Normal animation flow\n      if (phase === 'type' && count < graphemes.length) {\n        if (elapsed >= msPerChar) {\n          lastTime = currentTime\n          setCount((c) => c + 1)\n        }\n        rafId = requestAnimationFrame(animate)\n      } else if (phase === 'type' && count >= graphemes.length) {\n        setPhase('pause')\n        lastTime = currentTime\n      } else if (phase === 'pause') {\n        if (elapsed >= pauseMs) {\n          setPhase('delete')\n          lastTime = currentTime\n        } else {\n          rafId = requestAnimationFrame(animate)\n        }\n      } else if (phase === 'delete' && count > 0) {\n        if (elapsed >= deleteMsPerChar) {\n          lastTime = currentTime\n          setCount((c) => c - 1)\n        }\n        rafId = requestAnimationFrame(animate)\n      } else if (phase === 'delete' && count === 0) {\n        const isLast = safeIndex + 1 >= texts.length\n        if (isLast && !loop) {\n          isAnimatingRef.current = false\n          return\n        }\n        setIndex(isLast ? 0 : safeIndex + 1)\n        setCount(0)\n        setPhase('gap')\n        lastTime = currentTime\n      } else if (phase === 'gap') {\n        if (elapsed >= gapMs) {\n          setPhase('type')\n          lastTime = currentTime\n        } else {\n          rafId = requestAnimationFrame(animate)\n        }\n      }\n    }\n\n    rafId = requestAnimationFrame(animate)\n    return () => {\n      cancelAnimationFrame(rafId)\n      isAnimatingRef.current = false\n    }\n  }, [\n    phase,\n    count,\n    graphemes.length,\n    safeIndex,\n    texts.length,\n    loop,\n    msPerChar,\n    deleteMsPerChar,\n    pauseMs,\n    gapMs,\n    prefersReducedMotion,\n  ])\n\n  const longestText = React.useMemo(\n    () => texts.reduce((a, b) => (a.length > b.length ? a : b), ''),\n    [texts]\n  )\n\n  const visible = React.useMemo(\n    () => graphemes.slice(0, count).join(''),\n    [graphemes, count]\n  )\n\n  return {\n    visible,\n    longestText,\n    phase,\n    isAnimating: isAnimatingRef.current,\n    prefersReducedMotion,\n  }\n}\n\n/** Split text into grapheme clusters for proper emoji/unicode handling */\nfunction toGraphemes(str: string): string[] {\n  if (typeof Intl !== 'undefined' && Intl.Segmenter) {\n    const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' })\n    return [...segmenter.segment(str)].map((s) => s.segment)\n  }\n  // Fallback for older environments - spread handles most cases\n  return [...str]\n}\n",
      "type": "registry:hook"
    }
  ]
}