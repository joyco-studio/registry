{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "typewriter",
  "type": "registry:component",
  "title": "Typewriter",
  "description": "A lightweight typewriter text component that cycles through phrases with minimal JavaScript.",
  "files": [
    {
      "path": "registry/joyco/blocks/typewriter.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\n\nimport { cn } from '@/lib/utils'\n\ntype AriaLive = 'off' | 'polite' | 'assertive'\n\nexport interface TypewriterProps extends React.ComponentPropsWithoutRef<'span'> {\n  /**\n   * The list of texts to type. When more than one is provided, the component can\n   * automatically cycle through them.\n   */\n  texts: readonly string[]\n  /**\n   * Controlled active index.\n   */\n  index?: number\n  /**\n   * Uncontrolled initial index.\n   * @default 0\n   */\n  defaultIndex?: number\n  /**\n   * Called whenever the component *requests* an index change (e.g. when auto-advancing).\n   */\n  onIndexChange?: (index: number) => void\n  /**\n   * Whether to automatically cycle through `texts` (when `texts.length > 1`).\n   * Disabled automatically when `prefers-reduced-motion` is enabled.\n   * @default texts.length > 1\n   */\n  autoPlay?: boolean\n  /**\n   * Whether to loop back to the first text after the last.\n   * @default true\n   */\n  loop?: boolean\n  /**\n   * Typing speed in milliseconds per character.\n   * @default 60\n   */\n  msPerChar?: number\n  /**\n   * Pause after typing completes (before advancing to the next text).\n   * @default 900\n   */\n  pauseMs?: number\n  /**\n   * Typing speed in milliseconds per character while deleting.\n   * @default msPerChar\n   */\n  deleteMsPerChar?: number\n  /**\n   * Pause after deleting completes (before starting the next word).\n   * @default 150\n   */\n  gapMs?: number\n  /**\n   * Whether to render a blinking caret.\n   * @default true\n   */\n  caret?: boolean\n  /**\n   * Whether screen readers should announce text changes.\n   * Defaults to `off` to avoid noisy announcements when cycling.\n   * @default \"off\"\n   */\n  ariaLive?: AriaLive\n}\n\nfunction clampIndex(index: number, len: number) {\n  if (len <= 0) return 0\n  if (index < 0) return 0\n  if (index >= len) return len - 1\n  return index\n}\n\nfunction getCharCount(text: string) {\n  // Good enough for most UI strings (handles surrogate pairs).\n  return Math.max(0, Array.from(text).length)\n}\n\nfunction usePrefersReducedMotion() {\n  const [reduced, setReduced] = React.useState(false)\n\n  React.useEffect(() => {\n    const mq = window.matchMedia?.('(prefers-reduced-motion: reduce)')\n    if (!mq) return\n\n    const update = () => setReduced(mq.matches)\n    update()\n\n    // Safari < 14 uses addListener/removeListener.\n    if ('addEventListener' in mq) mq.addEventListener('change', update)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    else (mq as any).addListener(update)\n\n    return () => {\n      if ('removeEventListener' in mq) mq.removeEventListener('change', update)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      else (mq as any).removeListener(update)\n    }\n  }, [])\n\n  return reduced\n}\n\nfunction sleep(ms: number, signal?: AbortSignal) {\n  if (ms <= 0) return Promise.resolve()\n  return new Promise<void>((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(new DOMException('Aborted', 'AbortError'))\n      return\n    }\n\n    const id = window.setTimeout(resolve, ms)\n    signal?.addEventListener(\n      'abort',\n      () => {\n        window.clearTimeout(id)\n        reject(new DOMException('Aborted', 'AbortError'))\n      },\n      { once: true }\n    )\n  })\n}\n\nexport const Typewriter = React.forwardRef<HTMLSpanElement, TypewriterProps>(\n  (\n    {\n      texts,\n      index: indexProp,\n      defaultIndex = 0,\n      onIndexChange,\n      autoPlay: autoPlayProp,\n      loop = true,\n      msPerChar = 60,\n      pauseMs = 900,\n      deleteMsPerChar,\n      gapMs = 150,\n      caret = true,\n      ariaLive = 'off',\n      className,\n      style,\n      ...props\n    },\n    ref\n  ) => {\n    const prefersReducedMotion = usePrefersReducedMotion()\n\n    const isControlled = indexProp != null\n    const [uncontrolledIndex, setUncontrolledIndex] =\n      React.useState(defaultIndex)\n\n    const resolvedIndex = clampIndex(\n      isControlled ? (indexProp as number) : uncontrolledIndex,\n      texts.length\n    )\n\n    const setIndex = React.useCallback(\n      (next: number) => {\n        const clamped = clampIndex(next, texts.length)\n        if (!isControlled) setUncontrolledIndex(clamped)\n        onIndexChange?.(clamped)\n      },\n      [isControlled, onIndexChange, texts.length]\n    )\n\n    const autoPlay = autoPlayProp ?? texts.length > 1\n\n    const text = texts.length > 0 ? (texts[resolvedIndex] ?? '') : ''\n    const chars = getCharCount(text)\n    const typeDurationMs = Math.max(0, Math.round(chars * msPerChar))\n    const deleteDurationMs = Math.max(\n      0,\n      Math.round(chars * (deleteMsPerChar ?? msPerChar))\n    )\n    const textRef = React.useRef<HTMLSpanElement | null>(null)\n    const caretRef = React.useRef<HTMLSpanElement | null>(null)\n    const blinkRef = React.useRef<Animation | null>(null)\n\n    React.useEffect(() => {\n      const caretEl = caretRef.current\n      if (!caretEl) return\n\n      blinkRef.current?.cancel()\n      blinkRef.current = null\n\n      if (prefersReducedMotion) return\n      if (!caret) return\n\n      blinkRef.current = caretEl.animate([{ opacity: 1 }, { opacity: 0 }], {\n        duration: 1000,\n        iterations: Infinity,\n        easing: 'steps(1, end)',\n      })\n\n      return () => {\n        blinkRef.current?.cancel()\n        blinkRef.current = null\n      }\n    }, [caret, prefersReducedMotion])\n\n    React.useEffect(() => {\n      const textEl = textRef.current\n      const caretEl = caretRef.current\n      if (!textEl) return\n\n      // Stop any previous animations.\n      textEl.getAnimations().forEach((a) => a.cancel())\n      caretEl?.getAnimations().forEach((a) => a.cancel())\n\n      // Reset.\n      if (caretEl) {\n        caretEl.style.visibility = caret ? 'visible' : 'hidden'\n        caretEl.style.transform = 'translateX(0px)'\n      }\n      textEl.style.clipPath = 'none'\n      textEl.style.willChange = 'clip-path'\n\n      if (prefersReducedMotion) {\n        return\n      }\n\n      // Start hidden.\n      textEl.style.clipPath = 'inset(0 100% 0 0)'\n\n      // Measure once (no per-frame JS).\n      const widthPx = textEl.getBoundingClientRect().width\n      if (caretEl) {\n        const parentRect = textEl.parentElement?.getBoundingClientRect()\n        const textRect = textEl.getBoundingClientRect()\n        if (parentRect) {\n          caretEl.style.top = `${textRect.top - parentRect.top}px`\n        }\n        caretEl.style.height = `${textRect.height}px`\n      }\n      const steps = Math.max(1, chars)\n      const stepEasing = `steps(${steps}, end)`\n\n      const controller = new AbortController()\n      const { signal } = controller\n\n      const typeText = textEl.animate(\n        [{ clipPath: 'inset(0 100% 0 0)' }, { clipPath: 'inset(0 0% 0 0)' }],\n        { duration: typeDurationMs, easing: stepEasing, fill: 'forwards' }\n      )\n\n      const typeCaret =\n        caretEl && caret\n          ? caretEl.animate(\n              [\n                { transform: 'translateX(0px)' },\n                { transform: `translateX(${widthPx}px)` },\n              ],\n              { duration: typeDurationMs, easing: stepEasing, fill: 'forwards' }\n            )\n          : null\n\n      const run = async () => {\n        await Promise.all([typeText.finished, typeCaret?.finished])\n        await sleep(pauseMs, signal)\n\n        const delText = textEl.animate(\n          [{ clipPath: 'inset(0 0% 0 0)' }, { clipPath: 'inset(0 100% 0 0)' }],\n          { duration: deleteDurationMs, easing: stepEasing, fill: 'forwards' }\n        )\n\n        const delCaret =\n          caretEl && caret\n            ? caretEl.animate(\n                [\n                  { transform: `translateX(${widthPx}px)` },\n                  { transform: 'translateX(0px)' },\n                ],\n                {\n                  duration: deleteDurationMs,\n                  easing: stepEasing,\n                  fill: 'forwards',\n                }\n              )\n            : null\n\n        await Promise.all([delText.finished, delCaret?.finished])\n\n        if (caretEl) caretEl.style.visibility = 'hidden'\n        await sleep(gapMs, signal)\n        if (caretEl) caretEl.style.visibility = caret ? 'visible' : 'hidden'\n\n        if (!autoPlay) return\n        if (texts.length <= 1) return\n\n        const isLast = resolvedIndex >= texts.length - 1\n        if (isLast) {\n          if (!loop) return\n          setIndex(0)\n          return\n        }\n        setIndex(resolvedIndex + 1)\n      }\n\n      run().catch(() => {\n        // Abort/cancel -> ignore\n      })\n\n      return () => {\n        controller.abort()\n        typeText.cancel()\n        typeCaret?.cancel()\n      }\n    }, [\n      autoPlay,\n      caret,\n      chars,\n      deleteDurationMs,\n      gapMs,\n      loop,\n      pauseMs,\n      prefersReducedMotion,\n      resolvedIndex,\n      setIndex,\n      texts.length,\n      typeDurationMs,\n    ])\n\n    return (\n      <span\n        ref={ref}\n        data-slot=\"typewriter\"\n        aria-live={ariaLive}\n        aria-atomic={ariaLive === 'off' ? undefined : true}\n        className={cn('relative inline-block', className)}\n        style={style}\n        {...props}\n      >\n        {/* Measurement layer: renders all phrases, reserves stable width, not visible. */}\n        <span\n          data-slot=\"typewriter-measure\"\n          aria-hidden=\"true\"\n          className={cn(\n            'inline-grid items-baseline',\n            '*:col-start-1 *:row-start-1',\n            '*:whitespace-pre',\n            'invisible'\n          )}\n        >\n          {texts.map((t, i) => (\n            <span key={`${i}:${t}`}>{t}</span>\n          ))}\n        </span>\n\n        {/* Active layer: visible, animated via WAAPI. */}\n        <span\n          data-slot=\"typewriter-active\"\n          className=\"pointer-events-none absolute inset-0\"\n        >\n          <span\n            ref={textRef}\n            data-slot=\"typewriter-text\"\n            aria-hidden={false}\n            style={{\n              clipPath: prefersReducedMotion ? 'none' : 'inset(0 100% 0 0)',\n            }}\n          >\n            {text}\n          </span>\n          {caret ? (\n            <span\n              ref={caretRef}\n              data-slot=\"typewriter-caret\"\n              aria-hidden=\"true\"\n              className=\"absolute left-0 w-px bg-current\"\n            />\n          ) : null}\n        </span>\n      </span>\n    )\n  }\n)\n\nTypewriter.displayName = 'Typewriter'\n",
      "type": "registry:component"
    }
  ]
}