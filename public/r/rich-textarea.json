{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "rich-textarea",
  "type": "registry:component",
  "title": "Rich Textarea",
  "description": "A TipTap-powered chat textarea with mentions and feature slots.",
  "dependencies": [
    "@tiptap/core",
    "@tiptap/extension-document",
    "@tiptap/extension-hard-break",
    "@tiptap/extension-mention",
    "@tiptap/extension-paragraph",
    "@tiptap/extension-placeholder",
    "@tiptap/extension-text",
    "@tiptap/react",
    "@tiptap/suggestion",
    "@tiptap/pm"
  ],
  "files": [
    {
      "path": "registry/joyco/blocks/rich-textarea.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport type { AnyExtension, JSONContent } from '@tiptap/core'\nimport { EditorContent, useEditor } from '@tiptap/react'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport Document from '@tiptap/extension-document'\nimport HardBreak from '@tiptap/extension-hard-break'\nimport Paragraph from '@tiptap/extension-paragraph'\nimport Placeholder from '@tiptap/extension-placeholder'\nimport Text from '@tiptap/extension-text'\n\nimport { cn } from '@/lib/utils'\n\nexport type RichTextareaFeature = {\n  // TipTap extensions contributed by the feature.\n  extensions: AnyExtension[]\n  // Intercept keyboard events; return true to mark as handled.\n  keyHandler?: (context: { event: KeyboardEvent }) => boolean\n  // Serialize the editor doc into the external string format.\n  // Prefer calling base(doc) and only transform your feature's nodes.\n  serialize?: (\n    doc: ProseMirrorNode,\n    base: (doc: ProseMirrorNode) => string\n  ) => string\n  // Parse the external string format back into a TipTap doc.\n  // Prefer delegating to base for non-feature content.\n  parse?: (value: string, base: (value: string) => JSONContent) => JSONContent\n}\n\nexport type RichTextareaHandle = {\n  focus: () => void\n  clear: () => void\n  insertText: (text: string) => void\n}\n\nexport type RichTextareaProps = {\n  value: string\n  onChange: (next: string) => void\n  onSubmit: () => void\n  placeholder?: string\n  disabled?: boolean\n  extensions?: AnyExtension[]\n  features?: RichTextareaFeature[]\n  onKeyDown?: (event: KeyboardEvent) => void\n  className?: string\n  editorClassName?: string\n  'aria-label'?: string\n}\n\nfunction serializeDoc(node: ProseMirrorNode) {\n  if (node.type.name === 'doc') {\n    let output = ''\n    node.forEach((child, _, index) => {\n      if (index > 0) output += '\\n'\n      output += serializeDoc(child)\n    })\n    return output\n  }\n\n  if (node.type.name === 'paragraph') {\n    let output = ''\n    node.forEach((child) => {\n      output += serializeDoc(child)\n    })\n    return output\n  }\n\n  if (node.type.name === 'hardBreak') {\n    return '\\n'\n  }\n\n  if (node.isText) {\n    return node.text ?? ''\n  }\n\n  return ''\n}\n\nfunction pushTextNodesWithBreaks(target: JSONContent[], text: string) {\n  const parts = text.split('\\n')\n\n  parts.forEach((part, index) => {\n    if (part) {\n      target.push({ type: 'text', text: part })\n    }\n    if (index < parts.length - 1) {\n      target.push({ type: 'hardBreak' })\n    }\n  })\n}\n\nfunction parsePlainText(value: string): JSONContent {\n  const content: JSONContent[] = []\n  pushTextNodesWithBreaks(content, value)\n\n  return {\n    type: 'doc',\n    content: [\n      content.length > 0\n        ? { type: 'paragraph', content }\n        : { type: 'paragraph' },\n    ],\n  }\n}\n\nexport const RichTextarea = React.forwardRef<\n  RichTextareaHandle,\n  RichTextareaProps\n>(\n  (\n    {\n      value,\n      onChange,\n      onSubmit,\n      placeholder,\n      disabled = false,\n      extensions = [],\n      features,\n      onKeyDown,\n      className,\n      editorClassName,\n      'aria-label': ariaLabel,\n    },\n    ref\n  ) => {\n    const featureList = React.useMemo(\n      () => (features ?? []).filter(Boolean),\n      [features]\n    )\n\n    const serialize = React.useMemo(() => {\n      const baseSerialize = (doc: ProseMirrorNode) => serializeDoc(doc)\n      return featureList.reduce(\n        (acc, feature) =>\n          feature.serialize\n            ? (doc: ProseMirrorNode) => feature.serialize!(doc, acc)\n            : acc,\n        baseSerialize\n      )\n    }, [featureList])\n\n    const parse = React.useMemo(() => {\n      const baseParse = (nextValue: string) => parsePlainText(nextValue)\n      return featureList.reduceRight(\n        (acc, feature) =>\n          feature.parse\n            ? (nextValue: string) => feature.parse!(nextValue, acc)\n            : acc,\n        baseParse\n      )\n    }, [featureList])\n\n    const lastValueRef = React.useRef(value)\n\n    const editorClasses = React.useMemo(\n      () =>\n        cn(\n          'border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 dark:bg-input/30 min-h-12 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',\n          editorClassName\n        ),\n      [editorClassName]\n    )\n\n    const editor = useEditor({\n      extensions: [\n        Document,\n        Paragraph,\n        Text,\n        HardBreak,\n        Placeholder.configure({\n          placeholder: placeholder ?? '',\n          emptyEditorClass: 'is-editor-empty',\n        }),\n        ...featureList.flatMap((feature) => feature.extensions),\n        ...extensions,\n      ],\n      content: parse(value),\n      editable: !disabled,\n      editorProps: {\n        attributes: {\n          class: editorClasses,\n          'data-placeholder': placeholder ?? '',\n          'aria-label': ariaLabel ?? 'Message',\n          'aria-multiline': 'true',\n          role: 'textbox',\n        },\n        handleKeyDown: (_view, event) => {\n          onKeyDown?.(event)\n          if (event.defaultPrevented || disabled) {\n            return true\n          }\n\n          for (const feature of featureList) {\n            if (feature.keyHandler?.({ event })) {\n              return true\n            }\n          }\n\n          if (event.key === 'Enter' && !event.shiftKey) {\n            event.preventDefault()\n            handleSubmit()\n            return true\n          }\n\n          if (event.key === 'Enter' && event.shiftKey) {\n            event.preventDefault()\n            editor?.commands.setHardBreak()\n            return true\n          }\n\n          return false\n        },\n        handlePaste: (_view, event) => {\n          if (disabled) return true\n          const text = event.clipboardData?.getData('text/plain')\n          if (!text) return false\n          event.preventDefault()\n          editor?.commands.insertContent(text)\n          return true\n        },\n      },\n      onUpdate: ({ editor }) => {\n        const nextValue = serialize(editor.state.doc)\n        lastValueRef.current = nextValue\n        onChange(nextValue)\n      },\n    })\n\n    const handleSubmit = React.useCallback(() => {\n      if (!editor || disabled) return\n\n      const nextValue = serialize(editor.state.doc)\n      if (nextValue.trim().length === 0) return\n\n      onSubmit()\n\n      editor.commands.setContent(\n        { type: 'doc', content: [{ type: 'paragraph' }] },\n        false\n      )\n      lastValueRef.current = ''\n      onChange('')\n    }, [editor, disabled, onSubmit, onChange, serialize])\n\n    React.useEffect(() => {\n      if (!editor) return\n      editor.setEditable(!disabled)\n    }, [editor, disabled])\n\n    React.useEffect(() => {\n      if (!editor) return\n      if (value === lastValueRef.current) return\n\n      editor.commands.setContent(parse(value), false)\n      lastValueRef.current = value\n    }, [editor, parse, value])\n\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        focus: () => editor?.commands.focus('end'),\n        clear: () => {\n          if (!editor) return\n          editor.commands.setContent(\n            { type: 'doc', content: [{ type: 'paragraph' }] },\n            false\n          )\n          lastValueRef.current = ''\n          onChange('')\n        },\n        insertText: (text: string) => {\n          editor?.commands.insertContent(text)\n        },\n      }),\n      [editor, onChange]\n    )\n\n    return (\n      <div\n        className={cn('relative w-full', className)}\n        data-disabled={disabled}\n      >\n        <style>{`\n          .is-editor-empty::before {\n            content: attr(data-placeholder);\n            color: hsl(var(--muted-foreground));\n            float: left;\n            pointer-events: none;\n            height: 0;\n          }\n        `}</style>\n        {editor ? (\n          <EditorContent editor={editor} />\n        ) : (\n          <div\n            className={cn(editorClasses, 'is-editor-empty')}\n            data-placeholder={placeholder ?? ''}\n            aria-hidden=\"true\"\n          />\n        )}\n      </div>\n    )\n  }\n)\n\nRichTextarea.displayName = 'RichTextarea'\n",
      "type": "registry:component"
    },
    {
      "path": "registry/joyco/blocks/rich-textarea-mentions.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport type { JSONContent } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport Mention from '@tiptap/extension-mention'\nimport { ReactRenderer } from '@tiptap/react'\n\nimport { cn } from '@/lib/utils'\nimport type { RichTextareaFeature } from './rich-textarea'\n\nconst MENTION_TOKEN_REGEX = /@\\{([^|}]+)\\|([^}]+)\\}/g\n\nexport type MentionItem = {\n  id: string\n  label: string\n  avatarUrl?: string\n  subtitle?: string\n}\n\nexport type MentionMenuHandle = {\n  onKeyDown: (props: { event: KeyboardEvent }) => boolean\n}\n\nexport type MentionMenuProps = {\n  items: MentionItem[]\n  command: (item: MentionItem) => void\n}\n\nexport type MentionFeatureConfig = {\n  getItems: (query: string) => Promise<MentionItem[]> | MentionItem[]\n  MenuComponent: React.ForwardRefExoticComponent<\n    MentionMenuProps & React.RefAttributes<MentionMenuHandle>\n  >\n}\n\ntype MentionFeatureState = {\n  isOpen: boolean\n  onKeyDown: ((props: { event: KeyboardEvent }) => boolean) | null\n}\n\nexport const DefaultMentionMenu = React.forwardRef<\n  MentionMenuHandle,\n  MentionMenuProps\n>(({ items, command }, ref) => {\n  const [selectedIndex, setSelectedIndex] = React.useState(0)\n\n  React.useEffect(() => {\n    setSelectedIndex(0)\n  }, [items])\n\n  const selectItem = React.useCallback(\n    (index: number) => {\n      const item = items[index]\n      if (!item) return\n      command(item)\n    },\n    [items, command]\n  )\n\n  React.useImperativeHandle(\n    ref,\n    () => ({\n      onKeyDown: ({ event }) => {\n        if (event.key === 'ArrowUp') {\n          event.preventDefault()\n          setSelectedIndex((index) =>\n            items.length === 0 ? 0 : (index - 1 + items.length) % items.length\n          )\n          return true\n        }\n        if (event.key === 'ArrowDown') {\n          event.preventDefault()\n          setSelectedIndex((index) =>\n            items.length === 0 ? 0 : (index + 1) % items.length\n          )\n          return true\n        }\n        if (event.key === 'Enter') {\n          event.preventDefault()\n          selectItem(selectedIndex)\n          return true\n        }\n        return false\n      },\n    }),\n    [items.length, selectItem, selectedIndex]\n  )\n\n  if (items.length === 0) {\n    return (\n      <div className=\"text-muted-foreground px-3 py-2 text-sm\">\n        No results\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-1\">\n      {items.map((item, index) => (\n        <button\n          key={item.id}\n          type=\"button\"\n          className={cn(\n            'relative flex w-full cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-left text-sm outline-hidden',\n            index === selectedIndex\n              ? 'bg-accent text-accent-foreground'\n              : 'hover:bg-muted'\n          )}\n          onMouseDown={(event) => {\n            event.preventDefault()\n            selectItem(index)\n          }}\n          aria-selected={index === selectedIndex}\n          data-highlighted={index === selectedIndex ? '' : undefined}\n          role=\"option\"\n        >\n          {item.avatarUrl ? (\n            <img\n              src={item.avatarUrl}\n              alt=\"\"\n              className=\"size-6 rounded-full object-cover\"\n            />\n          ) : (\n            <span className=\"bg-muted text-muted-foreground flex size-6 items-center justify-center rounded-full text-xs font-semibold\">\n              {item.label.slice(0, 1).toUpperCase()}\n            </span>\n          )}\n          <div className=\"min-w-0\">\n            <div className=\"truncate font-medium\">{item.label}</div>\n            {item.subtitle ? (\n              <div className=\"text-muted-foreground truncate text-xs\">\n                {item.subtitle}\n              </div>\n            ) : null}\n          </div>\n        </button>\n      ))}\n    </div>\n  )\n})\n\nDefaultMentionMenu.displayName = 'DefaultMentionMenu'\n\nfunction serializeWithMentions(\n  node: ProseMirrorNode,\n  base: (doc: ProseMirrorNode) => string\n): string {\n  if (node.type.name === 'doc') {\n    let output = ''\n    node.forEach((child, _, index) => {\n      if (index > 0) output += '\\n'\n      output += serializeWithMentions(child, base)\n    })\n    return output\n  }\n\n  if (node.type.name === 'paragraph') {\n    let output = ''\n    node.forEach((child) => {\n      output += serializeWithMentions(child, base)\n    })\n    return output\n  }\n\n  if (node.type.name === 'hardBreak') {\n    return '\\n'\n  }\n\n  if (node.type.name === 'mention') {\n    const id = node.attrs?.id ?? ''\n    const label = node.attrs?.label ?? ''\n    return `@{${id}|${label}}`\n  }\n\n  return base(node)\n}\n\nfunction parseWithMentions(value: string): JSONContent {\n  const content: JSONContent[] = []\n  let lastIndex = 0\n  MENTION_TOKEN_REGEX.lastIndex = 0\n  let match = MENTION_TOKEN_REGEX.exec(value)\n\n  const pushTextWithBreaks = (text: string) => {\n    const parts = text.split('\\n')\n    parts.forEach((part, index) => {\n      if (part) {\n        content.push({ type: 'text', text: part })\n      }\n      if (index < parts.length - 1) {\n        content.push({ type: 'hardBreak' })\n      }\n    })\n  }\n\n  while (match) {\n    const [token, id, label] = match\n    const before = value.slice(lastIndex, match.index)\n    pushTextWithBreaks(before)\n\n    content.push({\n      type: 'mention',\n      attrs: {\n        id,\n        label,\n      },\n    })\n\n    lastIndex = match.index + token.length\n    match = MENTION_TOKEN_REGEX.exec(value)\n  }\n\n  const rest = value.slice(lastIndex)\n  pushTextWithBreaks(rest)\n\n  return {\n    type: 'doc',\n    content: [\n      content.length > 0\n        ? { type: 'paragraph', content }\n        : { type: 'paragraph' },\n    ],\n  }\n}\n\nfunction createMentionSuggestion(\n  config: MentionFeatureConfig,\n  stateRef: React.MutableRefObject<MentionFeatureState>\n) {\n  return {\n    char: '@',\n    startOfLine: false,\n    items: ({ query }: { query: string }) =>\n      /^[\\w-]*$/.test(query) ? config.getItems(query) : [],\n    allow: ({ range, state }: { range: { from: number }; state: any }) => {\n      if (range.from <= 1) return true\n      const previousChar = state.doc.textBetween(range.from - 1, range.from)\n      return /\\s/.test(previousChar)\n    },\n    render: () => {\n      let renderer: ReactRenderer | null = null\n      let container: HTMLDivElement | null = null\n\n      const setPosition = (clientRect?: () => DOMRect | null) => {\n        const rect = clientRect?.()\n        if (!rect || !container) return\n\n        const offset = 8\n        container.style.left = `${rect.left}px`\n        container.style.top = `${rect.bottom + offset}px`\n      }\n\n      const handleKeyDown = ({ event }: { event: KeyboardEvent }) => {\n        if (event.key === 'Escape') {\n          stateRef.current.isOpen = false\n          stateRef.current.onKeyDown = null\n          if (container) {\n            container.style.display = 'none'\n          }\n          return true\n        }\n        const handler = renderer?.ref as MentionMenuHandle | undefined\n        return handler?.onKeyDown({ event }) ?? false\n      }\n\n      return {\n        onStart: (props: any) => {\n          stateRef.current.isOpen = true\n          stateRef.current.onKeyDown = handleKeyDown\n\n          renderer = new ReactRenderer(config.MenuComponent, {\n            props: {\n              items: props.items,\n              command: props.command,\n            },\n            editor: props.editor,\n          })\n\n          container = document.createElement('div')\n          container.className =\n            'text-popover-foreground border-border shadow-md z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1'\n          container.style.position = 'fixed'\n\n          document.body.appendChild(container)\n          container.appendChild(renderer.element)\n\n          setPosition(props.clientRect)\n        },\n        onUpdate: (props: any) => {\n          stateRef.current.isOpen = true\n          stateRef.current.onKeyDown = handleKeyDown\n          renderer?.updateProps({\n            items: props.items,\n            command: props.command,\n          })\n          if (container) container.style.display = 'block'\n          setPosition(props.clientRect)\n        },\n        onKeyDown: (props: { event: KeyboardEvent }) => handleKeyDown(props),\n        onExit: () => {\n          stateRef.current.isOpen = false\n          stateRef.current.onKeyDown = null\n          renderer?.destroy()\n          renderer = null\n          container?.remove()\n          container = null\n        },\n      }\n    },\n  }\n}\n\nexport function useMentionsFeature(\n  config: MentionFeatureConfig\n): RichTextareaFeature {\n  const stateRef = React.useRef<MentionFeatureState>({\n    isOpen: false,\n    onKeyDown: null,\n  })\n\n  const suggestion = React.useMemo(\n    () => createMentionSuggestion(config, stateRef),\n    [config]\n  )\n\n  const mentionExtension = React.useMemo(\n    () =>\n      Mention.configure({\n        HTMLAttributes: {\n          class:\n            'rounded bg-blue-200 py-px text-blue-950 dark:bg-blue-800 dark:text-blue-50',\n          'data-mention': '',\n          'data-tag': '',\n        },\n        renderLabel({ node }) {\n          const label = node.attrs.label ?? node.attrs.id ?? ''\n          return `@${label}`\n        },\n        suggestion,\n      }),\n    [suggestion]\n  )\n\n  return React.useMemo(\n    () => ({\n      extensions: [mentionExtension],\n      keyHandler: ({ event }) =>\n        stateRef.current.isOpen\n          ? (stateRef.current.onKeyDown?.({ event }) ?? false)\n          : false,\n      serialize: (doc, base) => serializeWithMentions(doc, base),\n      parse: (value) => parseWithMentions(value),\n    }),\n    [mentionExtension]\n  )\n}\n",
      "type": "registry:lib"
    }
  ]
}